{"ast":null,"code":"/*\n    GISScaler class that finds parameters of features\n    Copyright (C) 2017 Hugo W.L. ter Doest\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\nvar Element = require('./Element');\n\nvar Feature = require('./Feature');\n\nvar Distribution = require('./Distribution'); // classes is an array of classes\n// features is an array of feature functions\n\n\nfunction GISScaler(featureSet, sample) {\n  this.featureSet = featureSet;\n  this.sample = sample;\n} // Returns true if a correction feature is necessary\n\n\nGISScaler.prototype.calculateMaxSumOfFeatures = function () {\n  var that = this;\n  this.C = 0;\n  this.featureSums = {};\n  var listOfSumValues = []; // Since feature functions are derived from the sample\n  // we can use the sample to calculate the max sum\n  // We look at each sample element only once\n\n  this.sample.elements.forEach(function (x) {\n    if (!that.featureSums[x.toString()]) {\n      var sum = 0;\n      that.featureSet.getFeatures().forEach(function (f) {\n        sum += f.apply(x);\n      });\n\n      if (sum > that.C) {\n        that.C = sum;\n      }\n\n      that.featureSums[x.toString()] = sum;\n      listOfSumValues.push(sum);\n    }\n  }); //console.log(\"GISScaler:calculateMaxSumOfFeatures:maxSum is \" + this.C);\n  // Check if a correction feature is necessary\n\n  listOfSumValues.sort(function (a, b) {\n    return a - b;\n  });\n  return listOfSumValues[0] !== listOfSumValues[listOfSumValues.length - 1];\n};\n\nGISScaler.prototype.addCorrectionFeature = function () {\n  if (this.calculateMaxSumOfFeatures()) {\n    //console.log(\"GISScaler:addCorrectionFeature:C is \" + this.C);\n    var that = this;\n\n    function f(x) {\n      if (that.featureSums[x.toString()] !== undefined) {\n        return that.C - that.featureSums[x.toString()];\n      }\n\n      return 0;\n    }\n\n    var correctionFeature = new Feature(f, \"Correction feature\", []); //console.log(\"GISScaler:addCorrectionFeature:correctionFeature \" + JSON.stringify(correctionFeature));\n\n    this.featureSet.addFeature(correctionFeature);\n  } else {//console.log(\"Correction feature not needed\");\n  }\n}; // This is the Generalised Iterative Scaling algorithm\n// It ends if the improvement in likelihood of the distribution does not\n// improve more than minImprovement or if the maximum number of iterations is\n// reached.\n\n\nGISScaler.prototype.run = function (maxIterations, minImprovement) {\n  this.iteration = 0;\n  this.improvement = 0;\n  this.addCorrectionFeature(); // Build up the distribution p\n\n  var alpha = new Array(this.featureSet.size());\n\n  for (var i = 0; i < alpha.length; i++) {\n    alpha[i] = 1;\n  }\n\n  var p = new Distribution(alpha, this.featureSet, this.sample); //console.log(\"Distribution created\");\n\n  p.prepare(); //console.log(\"Distribution prepared\");\n\n  var likelihood = p.logLikelihood();\n  var KLDistance = p.KullbackLieblerDistance();\n  var newAlpha = new Array(this.featureSet.size());\n  var observedExpectation = 0;\n  var expectationApprox = 0;\n\n  do {\n    //console.log(\"Iteration \" + this.iteration + \" - Log likelihood of sample: \" + likelihood + \" - Entropy: \" + p.entropy());\n    for (var i = 0; i < this.featureSet.size(); i++) {\n      observedExpectation = this.featureSet.getFeatures()[i].observedExpectation(this.sample);\n      expectationApprox = this.featureSet.getFeatures()[i].expectationApprox(p, this.sample); //console.log(\"Iteration \" + this.iteration + \" - Feature \" + i);\n\n      newAlpha[i] = p.alpha[i] * Math.pow(observedExpectation / expectationApprox, 1 / this.C); //console.log(\"GISScaler.run: old alpha[\" + i + \"]: \" + p.alpha[i]);\n      //console.log(\"GISScaler.run: new alpha[\" + i + \"]: \" + newAlpha[i]);\n    } // Make the newly calculated parameters current parameters\n\n\n    newAlpha.forEach(function (newAlpha_j, j) {\n      p.alpha[j] = newAlpha_j;\n    }); // Recalculate a priori and a posteriori probabilities\n\n    p.prepare();\n    this.iteration++;\n    var newLikelihood = p.logLikelihood();\n    var newKLDistance = p.KullbackLieblerDistance();\n    this.improvement = KLDistance - newKLDistance; //console.log(\"Iteration \" + this.iteration + \" - Old likelihood: \" + likelihood + \" - New likelihood: \" + newLikelihood);\n    //console.log(\"Iteration \" + this.iteration + \" - Old KL: \" + KLDistance + \" - New KL: \" + newKLDistance);\n\n    likelihood = newLikelihood;\n    KLDistance = newKLDistance;\n  } while (this.iteration < maxIterations && this.improvement > minImprovement); //} while (iteration < maxIterations);\n\n  /*\n  var that = this;\n  this.featureSet.getFeatures().forEach(function(f, j) {\n    console.log(\"Observed expectation of feature \" + j + \": \" + f.observedExpectation(that.sample) +\n      \" - Expection of feature according to p: \" + f.expectationApprox(p, that.sample));\n  });\n  */\n\n\n  return p;\n};\n\nmodule.exports = GISScaler;","map":{"version":3,"sources":["/Users/tenzy/Documents/work/vata-hackathon-fe/atva/node_modules/natural/lib/natural/classifiers/maxent/GISScaler.js"],"names":["Element","require","Feature","Distribution","GISScaler","featureSet","sample","prototype","calculateMaxSumOfFeatures","that","C","featureSums","listOfSumValues","elements","forEach","x","toString","sum","getFeatures","f","apply","push","sort","a","b","length","addCorrectionFeature","undefined","correctionFeature","addFeature","run","maxIterations","minImprovement","iteration","improvement","alpha","Array","size","i","p","prepare","likelihood","logLikelihood","KLDistance","KullbackLieblerDistance","newAlpha","observedExpectation","expectationApprox","Math","pow","newAlpha_j","j","newLikelihood","newKLDistance","module","exports"],"mappings":"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","sourcesContent":["/*\n    GISScaler class that finds parameters of features\n    Copyright (C) 2017 Hugo W.L. ter Doest\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nvar Element = require('./Element');\nvar Feature = require('./Feature');\nvar Distribution = require('./Distribution');\n\n// classes is an array of classes\n// features is an array of feature functions\nfunction GISScaler(featureSet, sample) {\n    this.featureSet = featureSet;\n    this.sample = sample;\n}\n\n// Returns true if a correction feature is necessary\nGISScaler.prototype.calculateMaxSumOfFeatures = function() {\n  var that = this;\n  this.C = 0;\n  this.featureSums = {};\n  var listOfSumValues = [];\n\n  // Since feature functions are derived from the sample\n  // we can use the sample to calculate the max sum\n  // We look at each sample element only once\n  this.sample.elements.forEach(function(x) {\n    if (!that.featureSums[x.toString()]) {\n      var sum = 0;\n      that.featureSet.getFeatures().forEach(function(f) {\n        sum += f.apply(x);\n      });\n      if (sum > that.C) {\n        that.C = sum;\n      }\n      that.featureSums[x.toString()] = sum;\n      listOfSumValues.push(sum);\n    }\n  });\n  //console.log(\"GISScaler:calculateMaxSumOfFeatures:maxSum is \" + this.C);\n\n  // Check if a correction feature is necessary\n  listOfSumValues.sort(function(a, b) {\n    return a - b;\n  });\n  return(listOfSumValues[0] !== listOfSumValues[listOfSumValues.length - 1]);\n};\n\nGISScaler.prototype.addCorrectionFeature = function() {\n  if (this.calculateMaxSumOfFeatures()) {\n    //console.log(\"GISScaler:addCorrectionFeature:C is \" + this.C);\n    var that = this;\n\n    function f(x) {\n      if (that.featureSums[x.toString()] !== undefined) {\n        return that.C - that.featureSums[x.toString()];\n      }\n      return 0;\n    }\n\n    var correctionFeature = new Feature(f, \"Correction feature\", []);\n    //console.log(\"GISScaler:addCorrectionFeature:correctionFeature \" + JSON.stringify(correctionFeature));\n    this.featureSet.addFeature(correctionFeature);\n  }\n  else {\n    //console.log(\"Correction feature not needed\");\n  }\n};\n\n// This is the Generalised Iterative Scaling algorithm\n// It ends if the improvement in likelihood of the distribution does not\n// improve more than minImprovement or if the maximum number of iterations is\n// reached.\nGISScaler.prototype.run = function(maxIterations, minImprovement) {\n  this.iteration = 0;\n  this.improvement = 0;\n\n  this.addCorrectionFeature();\n  // Build up the distribution p\n  var alpha = new Array(this.featureSet.size());\n  for (var i = 0; i < alpha.length; i++) {\n    alpha[i] = 1;\n  }\n  var p = new Distribution(alpha, this.featureSet, this.sample);\n  //console.log(\"Distribution created\");\n  p.prepare();\n  //console.log(\"Distribution prepared\");\n  var likelihood = p.logLikelihood();\n  var KLDistance = p.KullbackLieblerDistance();\n\n  var newAlpha = new Array(this.featureSet.size());\n  var observedExpectation = 0;\n  var expectationApprox = 0;\n  do {\n    //console.log(\"Iteration \" + this.iteration + \" - Log likelihood of sample: \" + likelihood + \" - Entropy: \" + p.entropy());\n    for (var i = 0; i < this.featureSet.size(); i++) {\n      observedExpectation = this.featureSet.getFeatures()[i].observedExpectation(this.sample);\n      expectationApprox = this.featureSet.getFeatures()[i].expectationApprox(p, this.sample);\n      //console.log(\"Iteration \" + this.iteration + \" - Feature \" + i);\n      newAlpha[i] = p.alpha[i] * Math.pow(observedExpectation / expectationApprox, 1 / this.C);\n\n      //console.log(\"GISScaler.run: old alpha[\" + i + \"]: \" + p.alpha[i]);\n      //console.log(\"GISScaler.run: new alpha[\" + i + \"]: \" + newAlpha[i]);\n    }\n\n    // Make the newly calculated parameters current parameters\n    newAlpha.forEach(function(newAlpha_j, j) {\n      p.alpha[j] = newAlpha_j;\n    });\n    // Recalculate a priori and a posteriori probabilities\n    p.prepare();\n\n    this.iteration++;\n    var newLikelihood = p.logLikelihood();\n    var newKLDistance = p.KullbackLieblerDistance();\n    this.improvement = KLDistance - newKLDistance;\n    //console.log(\"Iteration \" + this.iteration + \" - Old likelihood: \" + likelihood + \" - New likelihood: \" + newLikelihood);\n    //console.log(\"Iteration \" + this.iteration + \" - Old KL: \" + KLDistance + \" - New KL: \" + newKLDistance);\n\n    likelihood = newLikelihood;\n    KLDistance = newKLDistance;\n  } while ((this.iteration < maxIterations) && (this.improvement > minImprovement));\n  //} while (iteration < maxIterations);\n  /*\n  var that = this;\n  this.featureSet.getFeatures().forEach(function(f, j) {\n    console.log(\"Observed expectation of feature \" + j + \": \" + f.observedExpectation(that.sample) +\n      \" - Expection of feature according to p: \" + f.expectationApprox(p, that.sample));\n  });\n  */\n\n  return p;\n};\n\nmodule.exports = GISScaler;\n"]},"metadata":{},"sourceType":"script"}