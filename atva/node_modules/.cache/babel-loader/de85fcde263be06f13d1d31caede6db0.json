{"ast":null,"code":"/*\n Copyright (c) 2013, Rodrigo Gonz√°lez, Sapienlab All Rights Reserved.\n Available via MIT LICENSE. See https://github.com/roro89/jsonpack/blob/master/LICENSE.md for details.\n */\n(function (define) {\n  define([], function () {\n    var TOKEN_TRUE = -1;\n    var TOKEN_FALSE = -2;\n    var TOKEN_NULL = -3;\n    var TOKEN_EMPTY_STRING = -4;\n    var TOKEN_UNDEFINED = -5;\n\n    var pack = function pack(json, options) {\n      // Canonizes the options\n      options = options || {}; // A shorthand for debugging\n\n      var verbose = options.verbose || false;\n      verbose && console.log('Normalize the JSON Object'); // JSON as Javascript Object (Not string representation)\n\n      json = typeof json === 'string' ? this.JSON.parse(json) : json;\n      verbose && console.log('Creating a empty dictionary'); // The dictionary\n\n      var dictionary = {\n        strings: [],\n        integers: [],\n        floats: []\n      };\n      verbose && console.log('Creating the AST'); // The AST\n\n      var ast = function recursiveAstBuilder(item) {\n        verbose && console.log('Calling recursiveAstBuilder with ' + this.JSON.stringify(item)); // The type of the item\n\n        var type = typeof item; // Case 7: The item is null\n\n        if (item === null) {\n          return {\n            type: 'null',\n            index: TOKEN_NULL\n          };\n        } //add undefined \n\n\n        if (typeof item === 'undefined') {\n          return {\n            type: 'undefined',\n            index: TOKEN_UNDEFINED\n          };\n        } // Case 1: The item is Array Object\n\n\n        if (item instanceof Array) {\n          // Create a new sub-AST of type Array (@)\n          var ast = ['@']; // Add each items\n\n          for (var i in item) {\n            if (!item.hasOwnProperty(i)) continue;\n            ast.push(recursiveAstBuilder(item[i]));\n          } // And return\n\n\n          return ast;\n        } // Case 2: The item is Object\n\n\n        if (type === 'object') {\n          // Create a new sub-AST of type Object ($)\n          var ast = ['$']; // Add each items\n\n          for (var key in item) {\n            if (!item.hasOwnProperty(key)) continue;\n            ast.push(recursiveAstBuilder(key));\n            ast.push(recursiveAstBuilder(item[key]));\n          } // And return\n\n\n          return ast;\n        } // Case 3: The item empty string\n\n\n        if (item === '') {\n          return {\n            type: 'empty',\n            index: TOKEN_EMPTY_STRING\n          };\n        } // Case 4: The item is String\n\n\n        if (type === 'string') {\n          // The index of that word in the dictionary\n          var index = _indexOf.call(dictionary.strings, item); // If not, add to the dictionary and actualize the index\n\n\n          if (index == -1) {\n            dictionary.strings.push(_encode(item));\n            index = dictionary.strings.length - 1;\n          } // Return the token\n\n\n          return {\n            type: 'strings',\n            index: index\n          };\n        } // Case 5: The item is integer\n\n\n        if (type === 'number' && item % 1 === 0) {\n          // The index of that number in the dictionary\n          var index = _indexOf.call(dictionary.integers, item); // If not, add to the dictionary and actualize the index\n\n\n          if (index == -1) {\n            dictionary.integers.push(_base10To36(item));\n            index = dictionary.integers.length - 1;\n          } // Return the token\n\n\n          return {\n            type: 'integers',\n            index: index\n          };\n        } // Case 6: The item is float\n\n\n        if (type === 'number') {\n          // The index of that number in the dictionary\n          var index = _indexOf.call(dictionary.floats, item); // If not, add to the dictionary and actualize the index\n\n\n          if (index == -1) {\n            // Float not use base 36\n            dictionary.floats.push(item);\n            index = dictionary.floats.length - 1;\n          } // Return the token\n\n\n          return {\n            type: 'floats',\n            index: index\n          };\n        } // Case 7: The item is boolean\n\n\n        if (type === 'boolean') {\n          return {\n            type: 'boolean',\n            index: item ? TOKEN_TRUE : TOKEN_FALSE\n          };\n        } // Default\n\n\n        throw new Error('Unexpected argument of type ' + typeof item);\n      }(json); // A set of shorthands proxies for the length of the dictionaries\n\n\n      var stringLength = dictionary.strings.length;\n      var integerLength = dictionary.integers.length;\n      var floatLength = dictionary.floats.length;\n      verbose && console.log('Parsing the dictionary'); // Create a raw dictionary\n\n      var packed = dictionary.strings.join('|');\n      packed += '^' + dictionary.integers.join('|');\n      packed += '^' + dictionary.floats.join('|');\n      verbose && console.log('Parsing the structure'); // And add the structure\n\n      packed += '^' + function recursiveParser(item) {\n        verbose && console.log('Calling a recursiveParser with ' + this.JSON.stringify(item)); // If the item is Array, then is a object of\n        // type [object Object] or [object Array]\n\n        if (item instanceof Array) {\n          // The packed resulting\n          var packed = item.shift();\n\n          for (var i in item) {\n            if (!item.hasOwnProperty(i)) continue;\n            packed += recursiveParser(item[i]) + '|';\n          }\n\n          return (packed[packed.length - 1] === '|' ? packed.slice(0, -1) : packed) + ']';\n        } // A shorthand proxies\n\n\n        var type = item.type,\n            index = item.index;\n\n        if (type === 'strings') {\n          // Just return the base 36 of index\n          return _base10To36(index);\n        }\n\n        if (type === 'integers') {\n          // Return a base 36 of index plus stringLength offset\n          return _base10To36(stringLength + index);\n        }\n\n        if (type === 'floats') {\n          // Return a base 36 of index plus stringLength and integerLength offset\n          return _base10To36(stringLength + integerLength + index);\n        }\n\n        if (type === 'boolean') {\n          return item.index;\n        }\n\n        if (type === 'null') {\n          return TOKEN_NULL;\n        }\n\n        if (type === 'undefined') {\n          return TOKEN_UNDEFINED;\n        }\n\n        if (type === 'empty') {\n          return TOKEN_EMPTY_STRING;\n        }\n\n        throw new TypeError('The item is alien!');\n      }(ast);\n\n      verbose && console.log('Ending parser'); // If debug, return a internal representation of dictionary and stuff\n\n      if (options.debug) return {\n        dictionary: dictionary,\n        ast: ast,\n        packed: packed\n      };\n      return packed;\n    };\n\n    var unpack = function unpack(packed, options) {\n      // Canonizes the options\n      options = options || {}; // A raw buffer\n\n      var rawBuffers = packed.split('^'); // Create a dictionary\n\n      options.verbose && console.log('Building dictionary');\n      var dictionary = []; // Add the strings values\n\n      var buffer = rawBuffers[0];\n\n      if (buffer !== '') {\n        buffer = buffer.split('|');\n        options.verbose && console.log('Parse the strings dictionary');\n\n        for (var i = 0, n = buffer.length; i < n; i++) {\n          dictionary.push(_decode(buffer[i]));\n        }\n      } // Add the integers values\n\n\n      buffer = rawBuffers[1];\n\n      if (buffer !== '') {\n        buffer = buffer.split('|');\n        options.verbose && console.log('Parse the integers dictionary');\n\n        for (var i = 0, n = buffer.length; i < n; i++) {\n          dictionary.push(_base36To10(buffer[i]));\n        }\n      } // Add the floats values\n\n\n      buffer = rawBuffers[2];\n\n      if (buffer !== '') {\n        buffer = buffer.split('|');\n        options.verbose && console.log('Parse the floats dictionary');\n\n        for (var i = 0, n = buffer.length; i < n; i++) {\n          dictionary.push(parseFloat(buffer[i]));\n        }\n      } // Free memory\n\n\n      buffer = null;\n      options.verbose && console.log('Tokenizing the structure'); // Tokenizer the structure\n\n      var number36 = '';\n      var tokens = [];\n      var len = rawBuffers[3].length;\n\n      for (var i = 0; i < len; i++) {\n        var symbol = rawBuffers[3].charAt(i);\n\n        if (symbol === '|' || symbol === '$' || symbol === '@' || symbol === ']') {\n          if (number36) {\n            tokens.push(_base36To10(number36));\n            number36 = '';\n          }\n\n          symbol !== '|' && tokens.push(symbol);\n        } else {\n          number36 += symbol;\n        }\n      } // A shorthand proxy for tokens.length\n\n\n      var tokensLength = tokens.length; // The index of the next token to read\n\n      var tokensIndex = 0;\n      options.verbose && console.log('Starting recursive parser');\n      return function recursiveUnpackerParser() {\n        // Maybe '$' (object) or '@' (array)\n        var type = tokens[tokensIndex++];\n        options.verbose && console.log('Reading collection type ' + (type === '$' ? 'object' : 'Array')); // Parse an array\n\n        if (type === '@') {\n          var node = [];\n\n          for (; tokensIndex < tokensLength; tokensIndex++) {\n            var value = tokens[tokensIndex];\n            options.verbose && console.log('Read ' + value + ' symbol');\n            if (value === ']') return node;\n\n            if (value === '@' || value === '$') {\n              node.push(recursiveUnpackerParser());\n            } else {\n              switch (value) {\n                case TOKEN_TRUE:\n                  node.push(true);\n                  break;\n\n                case TOKEN_FALSE:\n                  node.push(false);\n                  break;\n\n                case TOKEN_NULL:\n                  node.push(null);\n                  break;\n\n                case TOKEN_UNDEFINED:\n                  node.push(undefined);\n                  break;\n\n                case TOKEN_EMPTY_STRING:\n                  node.push('');\n                  break;\n\n                default:\n                  node.push(dictionary[value]);\n              }\n            }\n          }\n\n          options.verbose && console.log('Parsed ' + this.JSON.stringify(node));\n          return node;\n        } // Parse a object\n\n\n        if (type === '$') {\n          var node = {};\n\n          for (; tokensIndex < tokensLength; tokensIndex++) {\n            var key = tokens[tokensIndex];\n            if (key === ']') return node;\n            if (key === TOKEN_EMPTY_STRING) key = '';else key = dictionary[key];\n            var value = tokens[++tokensIndex];\n\n            if (value === '@' || value === '$') {\n              node[key] = recursiveUnpackerParser();\n            } else {\n              switch (value) {\n                case TOKEN_TRUE:\n                  node[key] = true;\n                  break;\n\n                case TOKEN_FALSE:\n                  node[key] = false;\n                  break;\n\n                case TOKEN_NULL:\n                  node[key] = null;\n                  break;\n\n                case TOKEN_UNDEFINED:\n                  node[key] = undefined;\n                  break;\n\n                case TOKEN_EMPTY_STRING:\n                  node[key] = '';\n                  break;\n\n                default:\n                  node[key] = dictionary[value];\n              }\n            }\n          }\n\n          options.verbose && console.log('Parsed ' + this.JSON.stringify(node));\n          return node;\n        }\n\n        throw new TypeError('Bad token ' + type + ' isn\\'t a type');\n      }();\n    };\n    /**\n     * Get the index value of the dictionary\n     * @param {Object} dictionary a object that have two array attributes: 'string' and 'number'\n     * @param {Object} data\n     */\n\n\n    var _indexOfDictionary = function _indexOfDictionary(dictionary, value) {\n      // The type of the value\n      var type = typeof value; // If is boolean, return a boolean token\n\n      if (type === 'boolean') return value ? TOKEN_TRUE : TOKEN_FALSE; // If is null, return a... yes! the null token\n\n      if (value === null) return TOKEN_NULL; //add undefined\n\n      if (typeof value === 'undefined') return TOKEN_UNDEFINED;\n\n      if (value === '') {\n        return TOKEN_EMPTY_STRING;\n      }\n\n      if (type === 'string') {\n        value = _encode(value);\n\n        var index = _indexOf.call(dictionary.strings, value);\n\n        if (index === -1) {\n          dictionary.strings.push(value);\n          index = dictionary.strings.length - 1;\n        }\n      } // If has an invalid JSON type (example a function)\n\n\n      if (type !== 'string' && type !== 'number') {\n        throw new Error('The type is not a JSON type');\n      }\n\n      ;\n\n      if (type === 'string') {\n        // string\n        value = _encode(value);\n      } else if (value % 1 === 0) {\n        // integer\n        value = _base10To36(value);\n      } else {} // float\n      // If is number, \"serialize\" the value\n\n\n      value = type === 'number' ? _base10To36(value) : _encode(value); // Retrieve the index of that value in the dictionary\n\n      var index = _indexOf.call(dictionary[type], value); // If that value is not in the dictionary\n\n\n      if (index === -1) {\n        // Push the value\n        dictionary[type].push(value); // And return their index\n\n        index = dictionary[type].length - 1;\n      } // If the type is a number, then add the '+'  prefix character\n      // to differentiate that they is a number index. If not, then\n      // just return a 36-based representation of the index\n\n\n      return type === 'number' ? '+' + index : index;\n    };\n\n    var _encode = function _encode(str) {\n      if (typeof str !== 'string') return str;\n      return str.replace(/[\\+ \\|\\^\\%]/g, function (a) {\n        return {\n          ' ': '+',\n          '+': '%2B',\n          '|': '%7C',\n          '^': '%5E',\n          '%': '%25'\n        }[a];\n      });\n    };\n\n    var _decode = function _decode(str) {\n      if (typeof str !== 'string') return str;\n      return str.replace(/\\+|%2B|%7C|%5E|%25/g, function (a) {\n        return {\n          '+': ' ',\n          '%2B': '+',\n          '%7C': '|',\n          '%5E': '^',\n          '%25': '%'\n        }[a];\n      });\n    };\n\n    var _base10To36 = function _base10To36(number) {\n      return Number.prototype.toString.call(number, 36).toUpperCase();\n    };\n\n    var _base36To10 = function _base36To10(number) {\n      return parseInt(number, 36);\n    };\n\n    var _indexOf = Array.prototype.indexOf || function (obj, start) {\n      for (var i = start || 0, j = this.length; i < j; i++) {\n        if (this[i] === obj) {\n          return i;\n        }\n      }\n\n      return -1;\n    };\n\n    return {\n      JSON: JSON,\n      pack: pack,\n      unpack: unpack\n    };\n  });\n})(typeof define == 'undefined' || !define.amd ? function (deps, factory) {\n  var jsonpack = factory();\n  if (typeof exports != 'undefined') for (var key in jsonpack) {\n    exports[key] = jsonpack[key];\n  } else window.jsonpack = jsonpack;\n} : define);","map":{"version":3,"sources":["/Users/tenzy/Documents/work/vata-hackathon-fe/atva/node_modules/jsonpack/main.js"],"names":["define","TOKEN_TRUE","TOKEN_FALSE","TOKEN_NULL","TOKEN_EMPTY_STRING","TOKEN_UNDEFINED","pack","json","options","verbose","console","log","JSON","parse","dictionary","strings","integers","floats","ast","recursiveAstBuilder","item","stringify","type","index","Array","i","hasOwnProperty","push","key","_indexOf","call","_encode","length","_base10To36","Error","stringLength","integerLength","floatLength","packed","join","recursiveParser","shift","slice","TypeError","debug","unpack","rawBuffers","split","buffer","n","_decode","_base36To10","parseFloat","number36","tokens","len","symbol","charAt","tokensLength","tokensIndex","recursiveUnpackerParser","node","value","undefined","_indexOfDictionary","str","replace","a","number","Number","prototype","toString","toUpperCase","parseInt","indexOf","obj","start","j","amd","deps","factory","jsonpack","exports","window"],"mappings":"AAAA;;;;AAIA,CAAC,UAASA,MAAT,EAAiB;AAEjBA,EAAAA,MAAM,CAAC,EAAD,EAAK,YAAW;AAErB,QAAIC,UAAU,GAAG,CAAC,CAAlB;AACA,QAAIC,WAAW,GAAG,CAAC,CAAnB;AACA,QAAIC,UAAU,GAAG,CAAC,CAAlB;AACA,QAAIC,kBAAkB,GAAG,CAAC,CAA1B;AACA,QAAIC,eAAe,GAAG,CAAC,CAAvB;;AAEA,QAAIC,IAAI,GAAG,SAAPA,IAAO,CAASC,IAAT,EAAeC,OAAf,EAAwB;AAElC;AACAA,MAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB,CAHkC,CAKlC;;AACA,UAAIC,OAAO,GAAGD,OAAO,CAACC,OAAR,IAAmB,KAAjC;AAEAA,MAAAA,OAAO,IAAIC,OAAO,CAACC,GAAR,CAAY,2BAAZ,CAAX,CARkC,CAUlC;;AACAJ,MAAAA,IAAI,GAAG,OAAOA,IAAP,KAAgB,QAAhB,GAA2B,KAAKK,IAAL,CAAUC,KAAV,CAAgBN,IAAhB,CAA3B,GAAmDA,IAA1D;AAEAE,MAAAA,OAAO,IAAIC,OAAO,CAACC,GAAR,CAAY,6BAAZ,CAAX,CAbkC,CAelC;;AACA,UAAIG,UAAU,GAAG;AAChBC,QAAAA,OAAO,EAAG,EADM;AAEhBC,QAAAA,QAAQ,EAAG,EAFK;AAGhBC,QAAAA,MAAM,EAAG;AAHO,OAAjB;AAMAR,MAAAA,OAAO,IAAIC,OAAO,CAACC,GAAR,CAAY,kBAAZ,CAAX,CAtBkC,CAwBlC;;AACA,UAAIO,GAAG,GAAI,SAASC,mBAAT,CAA6BC,IAA7B,EAAmC;AAE7CX,QAAAA,OAAO,IAAIC,OAAO,CAACC,GAAR,CAAY,sCAAsC,KAAKC,IAAL,CAAUS,SAAV,CAAoBD,IAApB,CAAlD,CAAX,CAF6C,CAI7C;;AACA,YAAIE,IAAI,GAAG,OAAOF,IAAlB,CAL6C,CAO7C;;AACA,YAAIA,IAAI,KAAK,IAAb,EAAmB;AAClB,iBAAO;AACNE,YAAAA,IAAI,EAAG,MADD;AAENC,YAAAA,KAAK,EAAGpB;AAFF,WAAP;AAIA,SAb4C,CAe7C;;;AACA,YAAI,OAAOiB,IAAP,KAAgB,WAApB,EAAiC;AAChC,iBAAO;AACNE,YAAAA,IAAI,EAAG,WADD;AAENC,YAAAA,KAAK,EAAGlB;AAFF,WAAP;AAIA,SArB4C,CAuB7C;;;AACA,YAAKe,IAAI,YAAYI,KAArB,EAA4B;AAE3B;AACA,cAAIN,GAAG,GAAG,CAAC,GAAD,CAAV,CAH2B,CAK3B;;AACA,eAAK,IAAIO,CAAT,IAAcL,IAAd,EAAoB;AAEnB,gBAAI,CAACA,IAAI,CAACM,cAAL,CAAoBD,CAApB,CAAL,EAA6B;AAE7BP,YAAAA,GAAG,CAACS,IAAJ,CAASR,mBAAmB,CAACC,IAAI,CAACK,CAAD,CAAL,CAA5B;AACA,WAX0B,CAa3B;;;AACA,iBAAOP,GAAP;AAEA,SAxC4C,CA0C7C;;;AACA,YAAII,IAAI,KAAK,QAAb,EAAuB;AAEtB;AACA,cAAIJ,GAAG,GAAG,CAAC,GAAD,CAAV,CAHsB,CAKtB;;AACA,eAAK,IAAIU,GAAT,IAAgBR,IAAhB,EAAsB;AAErB,gBAAI,CAACA,IAAI,CAACM,cAAL,CAAoBE,GAApB,CAAL,EACC;AAEDV,YAAAA,GAAG,CAACS,IAAJ,CAASR,mBAAmB,CAACS,GAAD,CAA5B;AACAV,YAAAA,GAAG,CAACS,IAAJ,CAASR,mBAAmB,CAACC,IAAI,CAACQ,GAAD,CAAL,CAA5B;AACA,WAbqB,CAetB;;;AACA,iBAAOV,GAAP;AAEA,SA7D4C,CA+D7C;;;AACA,YAAIE,IAAI,KAAK,EAAb,EAAiB;AAChB,iBAAO;AACNE,YAAAA,IAAI,EAAG,OADD;AAENC,YAAAA,KAAK,EAAGnB;AAFF,WAAP;AAIA,SArE4C,CAuE7C;;;AACA,YAAIkB,IAAI,KAAK,QAAb,EAAuB;AAEtB;AACA,cAAIC,KAAK,GAAGM,QAAQ,CAACC,IAAT,CAAchB,UAAU,CAACC,OAAzB,EAAkCK,IAAlC,CAAZ,CAHsB,CAKtB;;;AACA,cAAIG,KAAK,IAAI,CAAC,CAAd,EAAiB;AAChBT,YAAAA,UAAU,CAACC,OAAX,CAAmBY,IAAnB,CAAwBI,OAAO,CAACX,IAAD,CAA/B;AACAG,YAAAA,KAAK,GAAGT,UAAU,CAACC,OAAX,CAAmBiB,MAAnB,GAA4B,CAApC;AACA,WATqB,CAWtB;;;AACA,iBAAO;AACNV,YAAAA,IAAI,EAAG,SADD;AAENC,YAAAA,KAAK,EAAGA;AAFF,WAAP;AAIA,SAxF4C,CA0F7C;;;AACA,YAAID,IAAI,KAAK,QAAT,IAAqBF,IAAI,GAAG,CAAP,KAAa,CAAtC,EAAyC;AAExC;AACA,cAAIG,KAAK,GAAGM,QAAQ,CAACC,IAAT,CAAchB,UAAU,CAACE,QAAzB,EAAmCI,IAAnC,CAAZ,CAHwC,CAKxC;;;AACA,cAAIG,KAAK,IAAI,CAAC,CAAd,EAAiB;AAChBT,YAAAA,UAAU,CAACE,QAAX,CAAoBW,IAApB,CAAyBM,WAAW,CAACb,IAAD,CAApC;AACAG,YAAAA,KAAK,GAAGT,UAAU,CAACE,QAAX,CAAoBgB,MAApB,GAA6B,CAArC;AACA,WATuC,CAWxC;;;AACA,iBAAO;AACNV,YAAAA,IAAI,EAAG,UADD;AAENC,YAAAA,KAAK,EAAGA;AAFF,WAAP;AAIA,SA3G4C,CA6G7C;;;AACA,YAAID,IAAI,KAAK,QAAb,EAAuB;AACtB;AACA,cAAIC,KAAK,GAAGM,QAAQ,CAACC,IAAT,CAAchB,UAAU,CAACG,MAAzB,EAAiCG,IAAjC,CAAZ,CAFsB,CAItB;;;AACA,cAAIG,KAAK,IAAI,CAAC,CAAd,EAAiB;AAChB;AACAT,YAAAA,UAAU,CAACG,MAAX,CAAkBU,IAAlB,CAAuBP,IAAvB;AACAG,YAAAA,KAAK,GAAGT,UAAU,CAACG,MAAX,CAAkBe,MAAlB,GAA2B,CAAnC;AACA,WATqB,CAWtB;;;AACA,iBAAO;AACNV,YAAAA,IAAI,EAAG,QADD;AAENC,YAAAA,KAAK,EAAGA;AAFF,WAAP;AAIA,SA9H4C,CAgI7C;;;AACA,YAAID,IAAI,KAAK,SAAb,EAAwB;AACvB,iBAAO;AACNA,YAAAA,IAAI,EAAG,SADD;AAENC,YAAAA,KAAK,EAAGH,IAAI,GAAGnB,UAAH,GAAgBC;AAFtB,WAAP;AAIA,SAtI4C,CAwI7C;;;AACA,cAAM,IAAIgC,KAAJ,CAAU,iCAAiC,OAAQd,IAAnD,CAAN;AAEA,OA3IS,CA2IPb,IA3IO,CAAV,CAzBkC,CAsKlC;;;AACA,UAAI4B,YAAY,GAAGrB,UAAU,CAACC,OAAX,CAAmBiB,MAAtC;AACA,UAAII,aAAa,GAAGtB,UAAU,CAACE,QAAX,CAAoBgB,MAAxC;AACA,UAAIK,WAAW,GAAGvB,UAAU,CAACG,MAAX,CAAkBe,MAApC;AAEAvB,MAAAA,OAAO,IAAIC,OAAO,CAACC,GAAR,CAAY,wBAAZ,CAAX,CA3KkC,CA6KlC;;AACA,UAAI2B,MAAM,GAAGxB,UAAU,CAACC,OAAX,CAAmBwB,IAAnB,CAAwB,GAAxB,CAAb;AACAD,MAAAA,MAAM,IAAI,MAAMxB,UAAU,CAACE,QAAX,CAAoBuB,IAApB,CAAyB,GAAzB,CAAhB;AACAD,MAAAA,MAAM,IAAI,MAAMxB,UAAU,CAACG,MAAX,CAAkBsB,IAAlB,CAAuB,GAAvB,CAAhB;AAEA9B,MAAAA,OAAO,IAAIC,OAAO,CAACC,GAAR,CAAY,uBAAZ,CAAX,CAlLkC,CAoLlC;;AACA2B,MAAAA,MAAM,IAAI,MAAO,SAASE,eAAT,CAAyBpB,IAAzB,EAA+B;AAE/CX,QAAAA,OAAO,IAAIC,OAAO,CAACC,GAAR,CAAY,oCAAoC,KAAKC,IAAL,CAAUS,SAAV,CAAoBD,IAApB,CAAhD,CAAX,CAF+C,CAI/C;AACA;;AACA,YAAKA,IAAI,YAAYI,KAArB,EAA4B;AAE3B;AACA,cAAIc,MAAM,GAAGlB,IAAI,CAACqB,KAAL,EAAb;;AAEA,eAAK,IAAIhB,CAAT,IAAcL,IAAd,EAAoB;AAEnB,gBAAI,CAACA,IAAI,CAACM,cAAL,CAAoBD,CAApB,CAAL,EACC;AAEDa,YAAAA,MAAM,IAAIE,eAAe,CAACpB,IAAI,CAACK,CAAD,CAAL,CAAf,GAA2B,GAArC;AACA;;AAED,iBAAO,CAACa,MAAM,CAACA,MAAM,CAACN,MAAP,GAAgB,CAAjB,CAAN,KAA8B,GAA9B,GAAoCM,MAAM,CAACI,KAAP,CAAa,CAAb,EAAgB,CAAC,CAAjB,CAApC,GAA0DJ,MAA3D,IAAqE,GAA5E;AAEA,SArB8C,CAuB/C;;;AACA,YAAIhB,IAAI,GAAGF,IAAI,CAACE,IAAhB;AAAA,YAAsBC,KAAK,GAAGH,IAAI,CAACG,KAAnC;;AAEA,YAAID,IAAI,KAAK,SAAb,EAAwB;AACvB;AACA,iBAAOW,WAAW,CAACV,KAAD,CAAlB;AACA;;AAED,YAAID,IAAI,KAAK,UAAb,EAAyB;AACxB;AACA,iBAAOW,WAAW,CAACE,YAAY,GAAGZ,KAAhB,CAAlB;AACA;;AAED,YAAID,IAAI,KAAK,QAAb,EAAuB;AACtB;AACA,iBAAOW,WAAW,CAACE,YAAY,GAAGC,aAAf,GAA+Bb,KAAhC,CAAlB;AACA;;AAED,YAAID,IAAI,KAAK,SAAb,EAAwB;AACvB,iBAAOF,IAAI,CAACG,KAAZ;AACA;;AAED,YAAID,IAAI,KAAK,MAAb,EAAqB;AACpB,iBAAOnB,UAAP;AACA;;AAED,YAAImB,IAAI,KAAK,WAAb,EAA0B;AACzB,iBAAOjB,eAAP;AACA;;AAED,YAAIiB,IAAI,KAAK,OAAb,EAAsB;AACrB,iBAAOlB,kBAAP;AACA;;AAED,cAAM,IAAIuC,SAAJ,CAAc,oBAAd,CAAN;AAEA,OA3De,CA2DbzB,GA3Da,CAAhB;;AA6DAT,MAAAA,OAAO,IAAIC,OAAO,CAACC,GAAR,CAAY,eAAZ,CAAX,CAlPkC,CAoPlC;;AACA,UAAIH,OAAO,CAACoC,KAAZ,EACC,OAAO;AACN9B,QAAAA,UAAU,EAAGA,UADP;AAENI,QAAAA,GAAG,EAAGA,GAFA;AAGNoB,QAAAA,MAAM,EAAGA;AAHH,OAAP;AAMD,aAAOA,MAAP;AAEA,KA9PD;;AAgQA,QAAIO,MAAM,GAAG,SAATA,MAAS,CAASP,MAAT,EAAiB9B,OAAjB,EAA0B;AAEtC;AACAA,MAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB,CAHsC,CAKtC;;AACA,UAAIsC,UAAU,GAAGR,MAAM,CAACS,KAAP,CAAa,GAAb,CAAjB,CANsC,CAQtC;;AACAvC,MAAAA,OAAO,CAACC,OAAR,IAAmBC,OAAO,CAACC,GAAR,CAAY,qBAAZ,CAAnB;AACA,UAAIG,UAAU,GAAG,EAAjB,CAVsC,CAYtC;;AACA,UAAIkC,MAAM,GAAGF,UAAU,CAAC,CAAD,CAAvB;;AACA,UAAIE,MAAM,KAAK,EAAf,EAAmB;AAClBA,QAAAA,MAAM,GAAGA,MAAM,CAACD,KAAP,CAAa,GAAb,CAAT;AACAvC,QAAAA,OAAO,CAACC,OAAR,IAAmBC,OAAO,CAACC,GAAR,CAAY,8BAAZ,CAAnB;;AACA,aAAK,IAAIc,CAAC,GAAC,CAAN,EAASwB,CAAC,GAACD,MAAM,CAAChB,MAAvB,EAA+BP,CAAC,GAACwB,CAAjC,EAAoCxB,CAAC,EAArC,EAAwC;AACvCX,UAAAA,UAAU,CAACa,IAAX,CAAgBuB,OAAO,CAACF,MAAM,CAACvB,CAAD,CAAP,CAAvB;AACA;AACD,OApBqC,CAsBtC;;;AACAuB,MAAAA,MAAM,GAAGF,UAAU,CAAC,CAAD,CAAnB;;AACA,UAAIE,MAAM,KAAK,EAAf,EAAmB;AAClBA,QAAAA,MAAM,GAAGA,MAAM,CAACD,KAAP,CAAa,GAAb,CAAT;AACAvC,QAAAA,OAAO,CAACC,OAAR,IAAmBC,OAAO,CAACC,GAAR,CAAY,+BAAZ,CAAnB;;AACA,aAAK,IAAIc,CAAC,GAAC,CAAN,EAASwB,CAAC,GAACD,MAAM,CAAChB,MAAvB,EAA+BP,CAAC,GAACwB,CAAjC,EAAoCxB,CAAC,EAArC,EAAwC;AACvCX,UAAAA,UAAU,CAACa,IAAX,CAAgBwB,WAAW,CAACH,MAAM,CAACvB,CAAD,CAAP,CAA3B;AACA;AACD,OA9BqC,CAgCtC;;;AACAuB,MAAAA,MAAM,GAAGF,UAAU,CAAC,CAAD,CAAnB;;AACA,UAAIE,MAAM,KAAK,EAAf,EAAmB;AAClBA,QAAAA,MAAM,GAAGA,MAAM,CAACD,KAAP,CAAa,GAAb,CAAT;AACAvC,QAAAA,OAAO,CAACC,OAAR,IAAmBC,OAAO,CAACC,GAAR,CAAY,6BAAZ,CAAnB;;AACA,aAAK,IAAIc,CAAC,GAAC,CAAN,EAASwB,CAAC,GAACD,MAAM,CAAChB,MAAvB,EAA+BP,CAAC,GAACwB,CAAjC,EAAoCxB,CAAC,EAArC,EAAwC;AACvCX,UAAAA,UAAU,CAACa,IAAX,CAAgByB,UAAU,CAACJ,MAAM,CAACvB,CAAD,CAAP,CAA1B;AACA;AACD,OAxCqC,CAyCtC;;;AACAuB,MAAAA,MAAM,GAAG,IAAT;AAEAxC,MAAAA,OAAO,CAACC,OAAR,IAAmBC,OAAO,CAACC,GAAR,CAAY,0BAAZ,CAAnB,CA5CsC,CA8CtC;;AACA,UAAI0C,QAAQ,GAAG,EAAf;AACA,UAAIC,MAAM,GAAG,EAAb;AACA,UAAIC,GAAG,GAACT,UAAU,CAAC,CAAD,CAAV,CAAcd,MAAtB;;AACA,WAAK,IAAIP,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG8B,GAApB,EAAyB9B,CAAC,EAA1B,EAA8B;AAC7B,YAAI+B,MAAM,GAAGV,UAAU,CAAC,CAAD,CAAV,CAAcW,MAAd,CAAqBhC,CAArB,CAAb;;AACA,YAAI+B,MAAM,KAAK,GAAX,IAAkBA,MAAM,KAAK,GAA7B,IAAoCA,MAAM,KAAK,GAA/C,IAAsDA,MAAM,KAAK,GAArE,EAA0E;AACzE,cAAIH,QAAJ,EAAc;AACbC,YAAAA,MAAM,CAAC3B,IAAP,CAAYwB,WAAW,CAACE,QAAD,CAAvB;AACAA,YAAAA,QAAQ,GAAG,EAAX;AACA;;AACDG,UAAAA,MAAM,KAAK,GAAX,IAAkBF,MAAM,CAAC3B,IAAP,CAAY6B,MAAZ,CAAlB;AACA,SAND,MAMO;AACNH,UAAAA,QAAQ,IAAIG,MAAZ;AACA;AACD,OA7DqC,CA+DtC;;;AACA,UAAIE,YAAY,GAAGJ,MAAM,CAACtB,MAA1B,CAhEsC,CAkEtC;;AACA,UAAI2B,WAAW,GAAG,CAAlB;AAEAnD,MAAAA,OAAO,CAACC,OAAR,IAAmBC,OAAO,CAACC,GAAR,CAAY,2BAAZ,CAAnB;AAEA,aAAQ,SAASiD,uBAAT,GAAmC;AAE1C;AACA,YAAItC,IAAI,GAAGgC,MAAM,CAACK,WAAW,EAAZ,CAAjB;AAEAnD,QAAAA,OAAO,CAACC,OAAR,IAAmBC,OAAO,CAACC,GAAR,CAAY,8BAA8BW,IAAI,KAAK,GAAT,GAAe,QAAf,GAA0B,OAAxD,CAAZ,CAAnB,CAL0C,CAO1C;;AACA,YAAIA,IAAI,KAAK,GAAb,EAAkB;AAEjB,cAAIuC,IAAI,GAAG,EAAX;;AAEA,iBAAOF,WAAW,GAAGD,YAArB,EAAmCC,WAAW,EAA9C,EAAkD;AACjD,gBAAIG,KAAK,GAAGR,MAAM,CAACK,WAAD,CAAlB;AACAnD,YAAAA,OAAO,CAACC,OAAR,IAAmBC,OAAO,CAACC,GAAR,CAAY,UAAUmD,KAAV,GAAkB,SAA9B,CAAnB;AACA,gBAAIA,KAAK,KAAK,GAAd,EACC,OAAOD,IAAP;;AACD,gBAAIC,KAAK,KAAK,GAAV,IAAiBA,KAAK,KAAK,GAA/B,EAAoC;AACnCD,cAAAA,IAAI,CAAClC,IAAL,CAAUiC,uBAAuB,EAAjC;AACA,aAFD,MAEO;AACN,sBAAOE,KAAP;AACC,qBAAK7D,UAAL;AACC4D,kBAAAA,IAAI,CAAClC,IAAL,CAAU,IAAV;AACA;;AACD,qBAAKzB,WAAL;AACC2D,kBAAAA,IAAI,CAAClC,IAAL,CAAU,KAAV;AACA;;AACD,qBAAKxB,UAAL;AACC0D,kBAAAA,IAAI,CAAClC,IAAL,CAAU,IAAV;AACA;;AACD,qBAAKtB,eAAL;AACCwD,kBAAAA,IAAI,CAAClC,IAAL,CAAUoC,SAAV;AACA;;AACD,qBAAK3D,kBAAL;AACCyD,kBAAAA,IAAI,CAAClC,IAAL,CAAU,EAAV;AACA;;AACD;AACCkC,kBAAAA,IAAI,CAAClC,IAAL,CAAUb,UAAU,CAACgD,KAAD,CAApB;AAjBF;AAoBA;AACD;;AAEDtD,UAAAA,OAAO,CAACC,OAAR,IAAmBC,OAAO,CAACC,GAAR,CAAY,YAAY,KAAKC,IAAL,CAAUS,SAAV,CAAoBwC,IAApB,CAAxB,CAAnB;AAEA,iBAAOA,IAAP;AAEA,SA/CyC,CAiD1C;;;AACA,YAAIvC,IAAI,KAAK,GAAb,EAAkB;AACjB,cAAIuC,IAAI,GAAG,EAAX;;AAEA,iBAAOF,WAAW,GAAGD,YAArB,EAAmCC,WAAW,EAA9C,EAAkD;AAEjD,gBAAI/B,GAAG,GAAG0B,MAAM,CAACK,WAAD,CAAhB;AAEA,gBAAI/B,GAAG,KAAK,GAAZ,EACC,OAAOiC,IAAP;AAED,gBAAIjC,GAAG,KAAKxB,kBAAZ,EACCwB,GAAG,GAAG,EAAN,CADD,KAGCA,GAAG,GAAGd,UAAU,CAACc,GAAD,CAAhB;AAED,gBAAIkC,KAAK,GAAGR,MAAM,CAAC,EAAEK,WAAH,CAAlB;;AAEA,gBAAIG,KAAK,KAAK,GAAV,IAAiBA,KAAK,KAAK,GAA/B,EAAoC;AACnCD,cAAAA,IAAI,CAACjC,GAAD,CAAJ,GAAYgC,uBAAuB,EAAnC;AACA,aAFD,MAEO;AACN,sBAAOE,KAAP;AACC,qBAAK7D,UAAL;AACC4D,kBAAAA,IAAI,CAACjC,GAAD,CAAJ,GAAY,IAAZ;AACA;;AACD,qBAAK1B,WAAL;AACC2D,kBAAAA,IAAI,CAACjC,GAAD,CAAJ,GAAY,KAAZ;AACA;;AACD,qBAAKzB,UAAL;AACC0D,kBAAAA,IAAI,CAACjC,GAAD,CAAJ,GAAY,IAAZ;AACA;;AACD,qBAAKvB,eAAL;AACCwD,kBAAAA,IAAI,CAACjC,GAAD,CAAJ,GAAYmC,SAAZ;AACA;;AACD,qBAAK3D,kBAAL;AACCyD,kBAAAA,IAAI,CAACjC,GAAD,CAAJ,GAAY,EAAZ;AACA;;AACD;AACCiC,kBAAAA,IAAI,CAACjC,GAAD,CAAJ,GAAYd,UAAU,CAACgD,KAAD,CAAtB;AAjBF;AAoBA;AACD;;AAEDtD,UAAAA,OAAO,CAACC,OAAR,IAAmBC,OAAO,CAACC,GAAR,CAAY,YAAY,KAAKC,IAAL,CAAUS,SAAV,CAAoBwC,IAApB,CAAxB,CAAnB;AAEA,iBAAOA,IAAP;AACA;;AAED,cAAM,IAAIlB,SAAJ,CAAc,eAAerB,IAAf,GAAsB,gBAApC,CAAN;AAEA,OApGM,EAAP;AAsGA,KA7KD;AA8KA;;;;;;;AAKA,QAAI0C,kBAAkB,GAAG,SAArBA,kBAAqB,CAASlD,UAAT,EAAqBgD,KAArB,EAA4B;AAEpD;AACA,UAAIxC,IAAI,GAAG,OAAOwC,KAAlB,CAHoD,CAKpD;;AACA,UAAIxC,IAAI,KAAK,SAAb,EACC,OAAOwC,KAAK,GAAG7D,UAAH,GAAgBC,WAA5B,CAPmD,CASpD;;AACA,UAAI4D,KAAK,KAAK,IAAd,EACC,OAAO3D,UAAP,CAXmD,CAapD;;AACA,UAAI,OAAO2D,KAAP,KAAiB,WAArB,EACC,OAAOzD,eAAP;;AAGD,UAAIyD,KAAK,KAAK,EAAd,EAAkB;AACjB,eAAO1D,kBAAP;AACA;;AAED,UAAIkB,IAAI,KAAK,QAAb,EAAuB;AACtBwC,QAAAA,KAAK,GAAG/B,OAAO,CAAC+B,KAAD,CAAf;;AACA,YAAIvC,KAAK,GAAGM,QAAQ,CAACC,IAAT,CAAchB,UAAU,CAACC,OAAzB,EAAkC+C,KAAlC,CAAZ;;AACA,YAAIvC,KAAK,KAAK,CAAC,CAAf,EAAkB;AACjBT,UAAAA,UAAU,CAACC,OAAX,CAAmBY,IAAnB,CAAwBmC,KAAxB;AACAvC,UAAAA,KAAK,GAAGT,UAAU,CAACC,OAAX,CAAmBiB,MAAnB,GAA4B,CAApC;AACA;AACD,OA7BmD,CA+BpD;;;AACA,UAAIV,IAAI,KAAK,QAAT,IAAqBA,IAAI,KAAK,QAAlC,EAA4C;AAC3C,cAAM,IAAIY,KAAJ,CAAU,6BAAV,CAAN;AACA;;AAAA;;AAED,UAAIZ,IAAI,KAAK,QAAb,EAAuB;AAAC;AACvBwC,QAAAA,KAAK,GAAG/B,OAAO,CAAC+B,KAAD,CAAf;AACA,OAFD,MAEO,IAAIA,KAAK,GAAG,CAAR,KAAc,CAAlB,EAAqB;AAAC;AAC5BA,QAAAA,KAAK,GAAG7B,WAAW,CAAC6B,KAAD,CAAnB;AACA,OAFM,MAEA,CAEN,CAJM,CAEC;AAIR;;;AACAA,MAAAA,KAAK,GAAGxC,IAAI,KAAK,QAAT,GAAoBW,WAAW,CAAC6B,KAAD,CAA/B,GAAyC/B,OAAO,CAAC+B,KAAD,CAAxD,CA7CoD,CA+CpD;;AACA,UAAIvC,KAAK,GAAGM,QAAQ,CAACC,IAAT,CAAchB,UAAU,CAACQ,IAAD,CAAxB,EAAgCwC,KAAhC,CAAZ,CAhDoD,CAkDpD;;;AACA,UAAIvC,KAAK,KAAK,CAAC,CAAf,EAAkB;AACjB;AACAT,QAAAA,UAAU,CAACQ,IAAD,CAAV,CAAiBK,IAAjB,CAAsBmC,KAAtB,EAFiB,CAGjB;;AACAvC,QAAAA,KAAK,GAAGT,UAAU,CAACQ,IAAD,CAAV,CAAiBU,MAAjB,GAA0B,CAAlC;AACA,OAxDmD,CA0DpD;AACA;AACA;;;AACA,aAAOV,IAAI,KAAK,QAAT,GAAoB,MAAMC,KAA1B,GAAkCA,KAAzC;AAEA,KA/DD;;AAiEA,QAAIQ,OAAO,GAAG,SAAVA,OAAU,CAASkC,GAAT,EAAc;AAC3B,UAAK,OAAOA,GAAP,KAAe,QAApB,EACC,OAAOA,GAAP;AAED,aAAOA,GAAG,CAACC,OAAJ,CAAY,cAAZ,EAA4B,UAASC,CAAT,EAAY;AAC9C,eAAQ;AACR,eAAM,GADE;AAER,eAAM,KAFE;AAGR,eAAM,KAHE;AAIR,eAAM,KAJE;AAKR,eAAM;AALE,SAAD,CAMJA,CANI,CAAP;AAOA,OARM,CAAP;AASA,KAbD;;AAeA,QAAIjB,OAAO,GAAG,SAAVA,OAAU,CAASe,GAAT,EAAc;AAC3B,UAAK,OAAOA,GAAP,KAAe,QAApB,EACC,OAAOA,GAAP;AAED,aAAOA,GAAG,CAACC,OAAJ,CAAY,qBAAZ,EAAmC,UAASC,CAAT,EAAY;AACrD,eAAQ;AACR,eAAM,GADE;AAER,iBAAQ,GAFA;AAGR,iBAAQ,GAHA;AAIR,iBAAQ,GAJA;AAKR,iBAAQ;AALA,SAAD,CAMJA,CANI,CAAP;AAOA,OARM,CAAP;AASA,KAbD;;AAeA,QAAIlC,WAAW,GAAG,SAAdA,WAAc,CAASmC,MAAT,EAAiB;AAClC,aAAOC,MAAM,CAACC,SAAP,CAAiBC,QAAjB,CAA0BzC,IAA1B,CAA+BsC,MAA/B,EAAuC,EAAvC,EAA2CI,WAA3C,EAAP;AACA,KAFD;;AAIA,QAAIrB,WAAW,GAAG,SAAdA,WAAc,CAASiB,MAAT,EAAiB;AAClC,aAAOK,QAAQ,CAACL,MAAD,EAAS,EAAT,CAAf;AACA,KAFD;;AAIA,QAAIvC,QAAQ,GAAGL,KAAK,CAAC8C,SAAN,CAAgBI,OAAhB,IACf,UAASC,GAAT,EAAcC,KAAd,EAAqB;AACpB,WAAK,IAAInD,CAAC,GAAImD,KAAK,IAAI,CAAlB,EAAsBC,CAAC,GAAG,KAAK7C,MAApC,EAA4CP,CAAC,GAAGoD,CAAhD,EAAmDpD,CAAC,EAApD,EAAwD;AACvD,YAAI,KAAKA,CAAL,MAAYkD,GAAhB,EAAqB;AACpB,iBAAOlD,CAAP;AACA;AACD;;AACD,aAAO,CAAC,CAAR;AACA,KARD;;AAUA,WAAO;AACNb,MAAAA,IAAI,EAAGA,IADD;AAENN,MAAAA,IAAI,EAAGA,IAFD;AAGNuC,MAAAA,MAAM,EAAGA;AAHH,KAAP;AAMA,GAljBK,CAAN;AAojBA,CAtjBD,EAsjBI,OAAO7C,MAAP,IAAiB,WAAjB,IAAgC,CAACA,MAAM,CAAC8E,GAAxC,GAA8C,UAASC,IAAT,EAAeC,OAAf,EAAwB;AACzE,MAAIC,QAAQ,GAAGD,OAAO,EAAtB;AACA,MAAK,OAAOE,OAAP,IAAkB,WAAvB,EACC,KAAK,IAAItD,GAAT,IAAgBqD,QAAhB;AACAC,IAAAA,OAAO,CAACtD,GAAD,CAAP,GAAeqD,QAAQ,CAACrD,GAAD,CAAvB;AADA,GADD,MAICuD,MAAM,CAACF,QAAP,GAAkBA,QAAlB;AACD,CAPG,GAOAjF,MA7jBJ","sourcesContent":["/*\n Copyright (c) 2013, Rodrigo Gonz√°lez, Sapienlab All Rights Reserved.\n Available via MIT LICENSE. See https://github.com/roro89/jsonpack/blob/master/LICENSE.md for details.\n */\n(function(define) {\n\n\tdefine([], function() {\n\n\t\tvar TOKEN_TRUE = -1;\n\t\tvar TOKEN_FALSE = -2;\n\t\tvar TOKEN_NULL = -3;\n\t\tvar TOKEN_EMPTY_STRING = -4;\n\t\tvar TOKEN_UNDEFINED = -5;\n\n\t\tvar pack = function(json, options) {\n\n\t\t\t// Canonizes the options\n\t\t\toptions = options || {};\n\n\t\t\t// A shorthand for debugging\n\t\t\tvar verbose = options.verbose || false;\n\n\t\t\tverbose && console.log('Normalize the JSON Object');\n\n\t\t\t// JSON as Javascript Object (Not string representation)\n\t\t\tjson = typeof json === 'string' ? this.JSON.parse(json) : json;\n\n\t\t\tverbose && console.log('Creating a empty dictionary');\n\n\t\t\t// The dictionary\n\t\t\tvar dictionary = {\n\t\t\t\tstrings : [],\n\t\t\t\tintegers : [],\n\t\t\t\tfloats : []\n\t\t\t};\n\n\t\t\tverbose && console.log('Creating the AST');\n\n\t\t\t// The AST\n\t\t\tvar ast = (function recursiveAstBuilder(item) {\n\n\t\t\t\tverbose && console.log('Calling recursiveAstBuilder with ' + this.JSON.stringify(item));\n\n\t\t\t\t// The type of the item\n\t\t\t\tvar type = typeof item;\n\n\t\t\t\t// Case 7: The item is null\n\t\t\t\tif (item === null) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype : 'null',\n\t\t\t\t\t\tindex : TOKEN_NULL\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//add undefined \n\t\t\t\tif (typeof item === 'undefined') {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype : 'undefined',\n\t\t\t\t\t\tindex : TOKEN_UNDEFINED\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Case 1: The item is Array Object\n\t\t\t\tif ( item instanceof Array) {\n\n\t\t\t\t\t// Create a new sub-AST of type Array (@)\n\t\t\t\t\tvar ast = ['@'];\n\n\t\t\t\t\t// Add each items\n\t\t\t\t\tfor (var i in item) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (!item.hasOwnProperty(i)) continue;\n\n\t\t\t\t\t\tast.push(recursiveAstBuilder(item[i]));\n\t\t\t\t\t}\n\n\t\t\t\t\t// And return\n\t\t\t\t\treturn ast;\n\n\t\t\t\t}\n\n\t\t\t\t// Case 2: The item is Object\n\t\t\t\tif (type === 'object') {\n\n\t\t\t\t\t// Create a new sub-AST of type Object ($)\n\t\t\t\t\tvar ast = ['$'];\n\n\t\t\t\t\t// Add each items\n\t\t\t\t\tfor (var key in item) {\n\n\t\t\t\t\t\tif (!item.hasOwnProperty(key))\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tast.push(recursiveAstBuilder(key));\n\t\t\t\t\t\tast.push(recursiveAstBuilder(item[key]));\n\t\t\t\t\t}\n\n\t\t\t\t\t// And return\n\t\t\t\t\treturn ast;\n\n\t\t\t\t}\n\n\t\t\t\t// Case 3: The item empty string\n\t\t\t\tif (item === '') {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype : 'empty',\n\t\t\t\t\t\tindex : TOKEN_EMPTY_STRING\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Case 4: The item is String\n\t\t\t\tif (type === 'string') {\n\n\t\t\t\t\t// The index of that word in the dictionary\n\t\t\t\t\tvar index = _indexOf.call(dictionary.strings, item);\n\n\t\t\t\t\t// If not, add to the dictionary and actualize the index\n\t\t\t\t\tif (index == -1) {\n\t\t\t\t\t\tdictionary.strings.push(_encode(item));\n\t\t\t\t\t\tindex = dictionary.strings.length - 1;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Return the token\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype : 'strings',\n\t\t\t\t\t\tindex : index\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Case 5: The item is integer\n\t\t\t\tif (type === 'number' && item % 1 === 0) {\n\n\t\t\t\t\t// The index of that number in the dictionary\n\t\t\t\t\tvar index = _indexOf.call(dictionary.integers, item);\n\n\t\t\t\t\t// If not, add to the dictionary and actualize the index\n\t\t\t\t\tif (index == -1) {\n\t\t\t\t\t\tdictionary.integers.push(_base10To36(item));\n\t\t\t\t\t\tindex = dictionary.integers.length - 1;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Return the token\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype : 'integers',\n\t\t\t\t\t\tindex : index\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Case 6: The item is float\n\t\t\t\tif (type === 'number') {\n\t\t\t\t\t// The index of that number in the dictionary\n\t\t\t\t\tvar index = _indexOf.call(dictionary.floats, item);\n\n\t\t\t\t\t// If not, add to the dictionary and actualize the index\n\t\t\t\t\tif (index == -1) {\n\t\t\t\t\t\t// Float not use base 36\n\t\t\t\t\t\tdictionary.floats.push(item);\n\t\t\t\t\t\tindex = dictionary.floats.length - 1;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Return the token\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype : 'floats',\n\t\t\t\t\t\tindex : index\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Case 7: The item is boolean\n\t\t\t\tif (type === 'boolean') {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype : 'boolean',\n\t\t\t\t\t\tindex : item ? TOKEN_TRUE : TOKEN_FALSE\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Default\n\t\t\t\tthrow new Error('Unexpected argument of type ' + typeof (item));\n\n\t\t\t})(json);\n\n\t\t\t// A set of shorthands proxies for the length of the dictionaries\n\t\t\tvar stringLength = dictionary.strings.length;\n\t\t\tvar integerLength = dictionary.integers.length;\n\t\t\tvar floatLength = dictionary.floats.length;\n\n\t\t\tverbose && console.log('Parsing the dictionary');\n\n\t\t\t// Create a raw dictionary\n\t\t\tvar packed = dictionary.strings.join('|');\n\t\t\tpacked += '^' + dictionary.integers.join('|');\n\t\t\tpacked += '^' + dictionary.floats.join('|');\n\n\t\t\tverbose && console.log('Parsing the structure');\n\n\t\t\t// And add the structure\n\t\t\tpacked += '^' + (function recursiveParser(item) {\n\n\t\t\t\tverbose && console.log('Calling a recursiveParser with ' + this.JSON.stringify(item));\n\n\t\t\t\t// If the item is Array, then is a object of\n\t\t\t\t// type [object Object] or [object Array]\n\t\t\t\tif ( item instanceof Array) {\n\n\t\t\t\t\t// The packed resulting\n\t\t\t\t\tvar packed = item.shift();\n\n\t\t\t\t\tfor (var i in item) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (!item.hasOwnProperty(i)) \n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tpacked += recursiveParser(item[i]) + '|';\n\t\t\t\t\t}\n\n\t\t\t\t\treturn (packed[packed.length - 1] === '|' ? packed.slice(0, -1) : packed) + ']';\n\n\t\t\t\t}\n\n\t\t\t\t// A shorthand proxies\n\t\t\t\tvar type = item.type, index = item.index;\n\n\t\t\t\tif (type === 'strings') {\n\t\t\t\t\t// Just return the base 36 of index\n\t\t\t\t\treturn _base10To36(index);\n\t\t\t\t}\n\n\t\t\t\tif (type === 'integers') {\n\t\t\t\t\t// Return a base 36 of index plus stringLength offset\n\t\t\t\t\treturn _base10To36(stringLength + index);\n\t\t\t\t}\n\n\t\t\t\tif (type === 'floats') {\n\t\t\t\t\t// Return a base 36 of index plus stringLength and integerLength offset\n\t\t\t\t\treturn _base10To36(stringLength + integerLength + index);\n\t\t\t\t}\n\n\t\t\t\tif (type === 'boolean') {\n\t\t\t\t\treturn item.index;\n\t\t\t\t}\n\n\t\t\t\tif (type === 'null') {\n\t\t\t\t\treturn TOKEN_NULL;\n\t\t\t\t}\n\n\t\t\t\tif (type === 'undefined') {\n\t\t\t\t\treturn TOKEN_UNDEFINED;\n\t\t\t\t}\n\n\t\t\t\tif (type === 'empty') {\n\t\t\t\t\treturn TOKEN_EMPTY_STRING;\n\t\t\t\t}\n\n\t\t\t\tthrow new TypeError('The item is alien!');\n\n\t\t\t})(ast);\n\n\t\t\tverbose && console.log('Ending parser');\n\n\t\t\t// If debug, return a internal representation of dictionary and stuff\n\t\t\tif (options.debug)\n\t\t\t\treturn {\n\t\t\t\t\tdictionary : dictionary,\n\t\t\t\t\tast : ast,\n\t\t\t\t\tpacked : packed\n\t\t\t\t};\n\n\t\t\treturn packed;\n\n\t\t};\n\n\t\tvar unpack = function(packed, options) {\n\n\t\t\t// Canonizes the options\n\t\t\toptions = options || {};\n\n\t\t\t// A raw buffer\n\t\t\tvar rawBuffers = packed.split('^');\n\n\t\t\t// Create a dictionary\n\t\t\toptions.verbose && console.log('Building dictionary');\n\t\t\tvar dictionary = [];\n\n\t\t\t// Add the strings values\n\t\t\tvar buffer = rawBuffers[0];\n\t\t\tif (buffer !== '') {\n\t\t\t\tbuffer = buffer.split('|');\n\t\t\t\toptions.verbose && console.log('Parse the strings dictionary');\n\t\t\t\tfor (var i=0, n=buffer.length; i<n; i++){\n\t\t\t\t\tdictionary.push(_decode(buffer[i]));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add the integers values\n\t\t\tbuffer = rawBuffers[1];\n\t\t\tif (buffer !== '') {\n\t\t\t\tbuffer = buffer.split('|');\n\t\t\t\toptions.verbose && console.log('Parse the integers dictionary');\n\t\t\t\tfor (var i=0, n=buffer.length; i<n; i++){\n\t\t\t\t\tdictionary.push(_base36To10(buffer[i]));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add the floats values\n\t\t\tbuffer = rawBuffers[2];\n\t\t\tif (buffer !== '') {\n\t\t\t\tbuffer = buffer.split('|')\n\t\t\t\toptions.verbose && console.log('Parse the floats dictionary');\n\t\t\t\tfor (var i=0, n=buffer.length; i<n; i++){\n\t\t\t\t\tdictionary.push(parseFloat(buffer[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Free memory\n\t\t\tbuffer = null;\n\n\t\t\toptions.verbose && console.log('Tokenizing the structure');\n\n\t\t\t// Tokenizer the structure\n\t\t\tvar number36 = '';\n\t\t\tvar tokens = [];\n\t\t\tvar len=rawBuffers[3].length;\n\t\t\tfor (var i = 0; i < len; i++) {\n\t\t\t\tvar symbol = rawBuffers[3].charAt(i);\n\t\t\t\tif (symbol === '|' || symbol === '$' || symbol === '@' || symbol === ']') {\n\t\t\t\t\tif (number36) {\n\t\t\t\t\t\ttokens.push(_base36To10(number36));\n\t\t\t\t\t\tnumber36 = '';\n\t\t\t\t\t}\n\t\t\t\t\tsymbol !== '|' && tokens.push(symbol);\n\t\t\t\t} else {\n\t\t\t\t\tnumber36 += symbol;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// A shorthand proxy for tokens.length\n\t\t\tvar tokensLength = tokens.length;\n\n\t\t\t// The index of the next token to read\n\t\t\tvar tokensIndex = 0;\n\n\t\t\toptions.verbose && console.log('Starting recursive parser');\n\n\t\t\treturn (function recursiveUnpackerParser() {\n\n\t\t\t\t// Maybe '$' (object) or '@' (array)\n\t\t\t\tvar type = tokens[tokensIndex++];\n\n\t\t\t\toptions.verbose && console.log('Reading collection type ' + (type === '$' ? 'object' : 'Array'));\n\n\t\t\t\t// Parse an array\n\t\t\t\tif (type === '@') {\n\n\t\t\t\t\tvar node = [];\n\n\t\t\t\t\tfor (; tokensIndex < tokensLength; tokensIndex++) {\n\t\t\t\t\t\tvar value = tokens[tokensIndex];\n\t\t\t\t\t\toptions.verbose && console.log('Read ' + value + ' symbol');\n\t\t\t\t\t\tif (value === ']')\n\t\t\t\t\t\t\treturn node;\n\t\t\t\t\t\tif (value === '@' || value === '$') {\n\t\t\t\t\t\t\tnode.push(recursiveUnpackerParser());\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tswitch(value) {\n\t\t\t\t\t\t\t\tcase TOKEN_TRUE:\n\t\t\t\t\t\t\t\t\tnode.push(true);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase TOKEN_FALSE:\n\t\t\t\t\t\t\t\t\tnode.push(false);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase TOKEN_NULL:\n\t\t\t\t\t\t\t\t\tnode.push(null);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase TOKEN_UNDEFINED:\n\t\t\t\t\t\t\t\t\tnode.push(undefined);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase TOKEN_EMPTY_STRING:\n\t\t\t\t\t\t\t\t\tnode.push('');\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tnode.push(dictionary[value]);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\toptions.verbose && console.log('Parsed ' + this.JSON.stringify(node));\n\n\t\t\t\t\treturn node;\n\n\t\t\t\t}\n\n\t\t\t\t// Parse a object\n\t\t\t\tif (type === '$') {\n\t\t\t\t\tvar node = {};\n\n\t\t\t\t\tfor (; tokensIndex < tokensLength; tokensIndex++) {\n\n\t\t\t\t\t\tvar key = tokens[tokensIndex];\n\n\t\t\t\t\t\tif (key === ']')\n\t\t\t\t\t\t\treturn node;\n\n\t\t\t\t\t\tif (key === TOKEN_EMPTY_STRING)\n\t\t\t\t\t\t\tkey = '';\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tkey = dictionary[key];\n\n\t\t\t\t\t\tvar value = tokens[++tokensIndex];\n\n\t\t\t\t\t\tif (value === '@' || value === '$') {\n\t\t\t\t\t\t\tnode[key] = recursiveUnpackerParser();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tswitch(value) {\n\t\t\t\t\t\t\t\tcase TOKEN_TRUE:\n\t\t\t\t\t\t\t\t\tnode[key] = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase TOKEN_FALSE:\n\t\t\t\t\t\t\t\t\tnode[key] = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase TOKEN_NULL:\n\t\t\t\t\t\t\t\t\tnode[key] = null;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase TOKEN_UNDEFINED:\n\t\t\t\t\t\t\t\t\tnode[key] = undefined;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase TOKEN_EMPTY_STRING:\n\t\t\t\t\t\t\t\t\tnode[key] = '';\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tnode[key] = dictionary[value];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\toptions.verbose && console.log('Parsed ' + this.JSON.stringify(node));\n\n\t\t\t\t\treturn node;\n\t\t\t\t}\n\n\t\t\t\tthrow new TypeError('Bad token ' + type + ' isn\\'t a type');\n\n\t\t\t})();\n\n\t\t}\n\t\t/**\n\t\t * Get the index value of the dictionary\n\t\t * @param {Object} dictionary a object that have two array attributes: 'string' and 'number'\n\t\t * @param {Object} data\n\t\t */\n\t\tvar _indexOfDictionary = function(dictionary, value) {\n\n\t\t\t// The type of the value\n\t\t\tvar type = typeof value;\n\n\t\t\t// If is boolean, return a boolean token\n\t\t\tif (type === 'boolean')\n\t\t\t\treturn value ? TOKEN_TRUE : TOKEN_FALSE;\n\n\t\t\t// If is null, return a... yes! the null token\n\t\t\tif (value === null)\n\t\t\t\treturn TOKEN_NULL;\n\n\t\t\t//add undefined\n\t\t\tif (typeof value === 'undefined')\n\t\t\t\treturn TOKEN_UNDEFINED;\n\n\n\t\t\tif (value === '') {\n\t\t\t\treturn TOKEN_EMPTY_STRING;\n\t\t\t}\n\n\t\t\tif (type === 'string') {\n\t\t\t\tvalue = _encode(value);\n\t\t\t\tvar index = _indexOf.call(dictionary.strings, value);\n\t\t\t\tif (index === -1) {\n\t\t\t\t\tdictionary.strings.push(value);\n\t\t\t\t\tindex = dictionary.strings.length - 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If has an invalid JSON type (example a function)\n\t\t\tif (type !== 'string' && type !== 'number') {\n\t\t\t\tthrow new Error('The type is not a JSON type');\n\t\t\t};\n\n\t\t\tif (type === 'string') {// string\n\t\t\t\tvalue = _encode(value);\n\t\t\t} else if (value % 1 === 0) {// integer\n\t\t\t\tvalue = _base10To36(value);\n\t\t\t} else {// float\n\n\t\t\t}\n\n\t\t\t// If is number, \"serialize\" the value\n\t\t\tvalue = type === 'number' ? _base10To36(value) : _encode(value);\n\n\t\t\t// Retrieve the index of that value in the dictionary\n\t\t\tvar index = _indexOf.call(dictionary[type], value);\n\n\t\t\t// If that value is not in the dictionary\n\t\t\tif (index === -1) {\n\t\t\t\t// Push the value\n\t\t\t\tdictionary[type].push(value);\n\t\t\t\t// And return their index\n\t\t\t\tindex = dictionary[type].length - 1;\n\t\t\t}\n\n\t\t\t// If the type is a number, then add the '+'  prefix character\n\t\t\t// to differentiate that they is a number index. If not, then\n\t\t\t// just return a 36-based representation of the index\n\t\t\treturn type === 'number' ? '+' + index : index;\n\n\t\t};\n\n\t\tvar _encode = function(str) {\n\t\t\tif ( typeof str !== 'string')\n\t\t\t\treturn str;\n\n\t\t\treturn str.replace(/[\\+ \\|\\^\\%]/g, function(a) {\n\t\t\t\treturn ({\n\t\t\t\t' ' : '+',\n\t\t\t\t'+' : '%2B',\n\t\t\t\t'|' : '%7C',\n\t\t\t\t'^' : '%5E',\n\t\t\t\t'%' : '%25'\n\t\t\t\t})[a]\n\t\t\t});\n\t\t};\n\n\t\tvar _decode = function(str) {\n\t\t\tif ( typeof str !== 'string')\n\t\t\t\treturn str;\n\n\t\t\treturn str.replace(/\\+|%2B|%7C|%5E|%25/g, function(a) {\n\t\t\t\treturn ({\n\t\t\t\t'+' : ' ',\n\t\t\t\t'%2B' : '+',\n\t\t\t\t'%7C' : '|',\n\t\t\t\t'%5E' : '^',\n\t\t\t\t'%25' : '%'\n\t\t\t\t})[a]\n\t\t\t})\n\t\t};\n\n\t\tvar _base10To36 = function(number) {\n\t\t\treturn Number.prototype.toString.call(number, 36).toUpperCase();\n\t\t};\n\n\t\tvar _base36To10 = function(number) {\n\t\t\treturn parseInt(number, 36);\n\t\t};\n\n\t\tvar _indexOf = Array.prototype.indexOf ||\n\t\tfunction(obj, start) {\n\t\t\tfor (var i = (start || 0), j = this.length; i < j; i++) {\n\t\t\t\tif (this[i] === obj) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t};\n\n\t\treturn {\n\t\t\tJSON : JSON,\n\t\t\tpack : pack,\n\t\t\tunpack : unpack\n\t\t};\n\n\t});\n\n})( typeof define == 'undefined' || !define.amd ? function(deps, factory) {\n\tvar jsonpack = factory();\n\tif ( typeof exports != 'undefined')\n\t\tfor (var key in jsonpack)\n\t\texports[key] = jsonpack[key];\n\telse\n\t\twindow.jsonpack = jsonpack;\n} : define);\n"]},"metadata":{},"sourceType":"script"}