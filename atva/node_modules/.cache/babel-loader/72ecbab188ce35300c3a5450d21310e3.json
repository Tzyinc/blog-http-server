{"ast":null,"code":"/*!\r\n* wordpos.js\r\n*\r\n*    Node.js part-of-speech utilities using WordNet database.\r\n*\r\n* Copyright (c) 2012-2016 mooster@42at.com\r\n* https://github.com/moos/wordpos\r\n*\r\n* Released under MIT license\r\n*/\nvar _ = require('underscore')._,\n    util = require('util'),\n    stopwords = require('../lib/natural/util/stopwords').words,\n    stopwordsStr = makeStopwordString(stopwords),\n    WNdb = require('wordnet-db'),\n    DataFile = require('./dataFile'),\n    IndexFile = require('./indexFile');\n\nfunction normalize(word) {\n  return word.toLowerCase().replace(/\\s+/g, '_');\n}\n\nfunction makeStopwordString(stopwords) {\n  return ' ' + stopwords.join(' ') + ' ';\n}\n\nfunction isStopword(stopwords, word) {\n  return stopwords.indexOf(' ' + word + ' ') >= 0;\n}\n\nfunction tokenizer(str) {\n  return str.split(/\\W+/); //_.without(results,'',' ')\n}\n\nfunction prepText(text) {\n  if (_.isArray(text)) return text;\n\n  var deduped = _.uniq(tokenizer(text));\n\n  if (!this.options.stopwords) return deduped;\n  return _.reject(deduped, _.bind(isStopword, null, _.isString(this.options.stopwords) ? this.options.stopwords : stopwordsStr));\n}\n/**\r\n * factory for main lookup function\r\n *\r\n * @param pos {string} - n/v/a/r\r\n * @returns {Function} - lookup function bound to POS\r\n */\n\n\nfunction lookup(pos) {\n  return function (word, callback) {\n    var profile = this.options.profile,\n        start = profile && new Date(),\n        files = this.getFilesFor(pos),\n        args = [];\n    word = normalize(word); // lookup index\n\n    return files.index.lookup(word).then(function (result) {\n      if (result) {\n        // lookup data\n        return files.data.lookup(result.synsetOffset).then(done);\n      } else {\n        // not found in index\n        return done([]);\n      }\n    }).catch(done);\n\n    function done(results) {\n      if (results instanceof Error) {\n        args.push([], word);\n      } else {\n        args.push(results, word);\n      } //console.log(3333, args)\n\n\n      profile && args.push(new Date() - start);\n      nextTick(callback, args);\n      return results;\n    }\n  };\n}\n/**\r\n * isX() factory function\r\n *\r\n * @param pos {string} - n/v/a/r\r\n * @returns {Function}\r\n */\n\n\nfunction is(pos) {\n  return function (word, callback, _noprofile) {\n    // disable profiling when isX() used internally\n    var profile = this.options.profile && !_noprofile,\n        start = profile && new Date(),\n        args = [],\n        index = this.getFilesFor(pos).index;\n    word = normalize(word);\n    return index.lookup(word).then(function (record) {\n      var result = !!record;\n      args.push(result, word);\n      profile && args.push(new Date() - start);\n      nextTick(callback, args);\n      return result;\n    });\n  };\n}\n/**\r\n * getX() factory function\r\n *\r\n * @param isFn {function} - an isX() function\r\n * @returns {Function}\r\n */\n\n\nfunction get(isFn) {\n  return function (text, callback, _noprofile) {\n    var profile = this.options.profile && !_noprofile,\n        start = profile && new Date(),\n        words = this.parse(text),\n        results = [],\n        self = this; //if (!n) return (process.nextTick(done),0);\n\n    return Promise.all(words.map(exec)).then(done);\n\n    function exec(word) {\n      return self[isFn].call(self, word, null,\n      /*_noprofile*/\n      true).then(function collect(result) {\n        result && results.push(word);\n      });\n    }\n\n    function done() {\n      var args = [results];\n      profile && args.push(new Date() - start);\n      nextTick(callback, args);\n      return results;\n    }\n  };\n} // setImmediate executes callback AFTER promise handlers.\n// Without it, exceptions in callback may be caught by Promise.\n\n\nfunction nextTick(fn, args) {\n  if (fn) {\n    fn.apply(null, args);\n  }\n}\n/**\r\n * @class WordPOS\r\n * @param options {object} -- @see WordPOS.defaults\r\n * @constructor\r\n */\n\n\nvar WordPOS = function (options) {\n  var dictPath;\n  this.options = _.defaults({}, _.isObject(options) && options || {}, {\n    dictPath: WNdb.path\n  }, WordPOS.defaults);\n  dictPath = this.options.dictPath;\n  this.nounIndex = new IndexFile(dictPath, 'noun');\n  this.verbIndex = new IndexFile(dictPath, 'verb');\n  this.adjIndex = new IndexFile(dictPath, 'adj');\n  this.advIndex = new IndexFile(dictPath, 'adv');\n  this.nounData = new DataFile(dictPath, 'noun');\n  this.verbData = new DataFile(dictPath, 'verb');\n  this.adjData = new DataFile(dictPath, 'adj');\n  this.advData = new DataFile(dictPath, 'adv'); // define randX() functions\n\n  require('./rand').init(this);\n\n  if (_.isArray(this.options.stopwords)) {\n    this.options.stopwords = makeStopwordString(this.options.stopwords);\n  }\n};\n\nWordPOS.defaults = {\n  /**\r\n   * path to WordNet data (override only if not using wordnet-db)\r\n   */\n  dictPath: '',\n\n  /**\r\n   * enable profiling, time in msec returned as second argument in callback\r\n   */\n  profile: false,\n\n  /**\r\n   * if true, exclude standard stopwords.\r\n   * if array, stopwords to exclude, eg, ['all','of','this',...]\r\n   * if false, do not filter any stopwords.\r\n   */\n  stopwords: true\n};\nvar wordposProto = WordPOS.prototype;\n/**\r\n * lookup a word in all indexes\r\n *\r\n * @param word {string} - search word\r\n * @param callback {Function} (optional) - callback with (results, word) signature\r\n * @returns {Promise}\r\n */\n\nwordposProto.lookup = function (word, callback) {\n  var self = this,\n      results = [],\n      profile = this.options.profile,\n      start = profile && new Date(),\n      methods = ['lookupAdverb', 'lookupAdjective', 'lookupVerb', 'lookupNoun'];\n  return Promise.all(methods.map(exec)).then(done).catch(error);\n\n  function exec(method) {\n    return self[method].call(self, word).then(function collect(result) {\n      results = results.concat(result);\n    });\n  }\n\n  function done() {\n    var args = [results, word];\n    profile && args.push(new Date() - start);\n    nextTick(callback, args);\n    return results;\n  }\n\n  function error(err) {\n    nextTick(callback, [[], word]);\n    throw err;\n  }\n};\n/**\r\n * getPOS() - Find all POS for all words in given string\r\n *\r\n * @param text {string} - words to lookup for POS\r\n * @param callback {function} (optional) - receives object with words broken into POS or 'rest', ie,\r\n * \t    Object: {nouns:[], verbs:[], adjectives:[], adverbs:[], rest:[]}\r\n * @return Promise - resolve function receives data object\r\n */\n\n\nwordposProto.getPOS = function (text, callback) {\n  var self = this,\n      data = {\n    nouns: [],\n    verbs: [],\n    adjectives: [],\n    adverbs: [],\n    rest: []\n  },\n      profile = this.options.profile,\n      start = profile && new Date(),\n      words = this.parse(text),\n      methods = ['getAdverbs', 'getAdjectives', 'getVerbs', 'getNouns'];\n  return Promise.all(methods.map(exec)).then(done).catch(error);\n\n  function exec(method) {\n    return self[method].call(self, text, null, true).then(function collect(results) {\n      // getAdjectives --> adjectives\n      var pos = method.replace('get', '').toLowerCase();\n      data[pos] = results;\n    });\n  }\n\n  function done() {\n    var matches = _(data).chain().values().flatten().uniq().value(),\n        args = [data];\n\n    data.rest = _(words).difference(matches);\n    profile && args.push(new Date() - start);\n    nextTick(callback, args);\n    return data;\n  }\n\n  function error(err) {\n    nextTick(callback, []);\n    throw err;\n  }\n};\n/**\r\n * get index and data files for given pos\r\n *\r\n * @param pos {string} - n/v/a/r\r\n * @returns {object} - keys {index, data}\r\n */\n\n\nwordposProto.getFilesFor = function (pos) {\n  switch (pos) {\n    case 'n':\n      return {\n        index: this.nounIndex,\n        data: this.nounData\n      };\n\n    case 'v':\n      return {\n        index: this.verbIndex,\n        data: this.verbData\n      };\n\n    case 'a':\n    case 's':\n      return {\n        index: this.adjIndex,\n        data: this.adjData\n      };\n\n    case 'r':\n      return {\n        index: this.advIndex,\n        data: this.advData\n      };\n  }\n\n  return {};\n};\n/**\r\n * lookupX() - Lookup word definition if already know POS\r\n * @see lookup\r\n */\n\n\nwordposProto.lookupAdjective = lookup('a');\nwordposProto.lookupAdverb = lookup('r');\nwordposProto.lookupNoun = lookup('n');\nwordposProto.lookupVerb = lookup('v');\n/**\r\n * isX() - Test if word is given POS\r\n * @see is\r\n */\n\nwordposProto.isAdjective = is('a');\nwordposProto.isAdverb = is('r');\nwordposProto.isNoun = is('n');\nwordposProto.isVerb = is('v');\n/**\r\n * getX() - Find all words in string that are given POS\r\n * @see get\r\n */\n\nwordposProto.getAdjectives = get('isAdjective');\nwordposProto.getAdverbs = get('isAdverb');\nwordposProto.getNouns = get('isNoun');\nwordposProto.getVerbs = get('isVerb');\n/**\r\n * parse - get deduped, less stopwords\r\n *\r\n * @param text {string|array} - string of words to parse.  If array is given, it is left in tact.\r\n * @returns {array}\r\n */\n\nwordposProto.parse = prepText;\n/**\r\n * seek - get record at offset for pos\r\n *\r\n * @param offset {number} - synset offset\r\n * @param pos {string} - POS a/r/n/v\r\n * @param callback {function} - optional callback\r\n * @returns Promise\r\n */\n\nwordposProto.seek = function (offset, pos, callback) {\n  offset = Number(offset);\n  if (_.isNaN(offset) || offset <= 0) return error('offset must be valid positive number.');\n  var data = this.getFilesFor(pos).data;\n  if (!data) return error('Incorrect POS - 2nd argument must be a, r, n or v.');\n  return data.lookup(offset, callback);\n\n  function error(msg) {\n    var err = new Error(msg);\n    callback && callback(err, {});\n    return Promise.reject(err);\n  }\n};\n/**\r\n * access to WordNet DB\r\n * @type {object}\r\n */\n\n\nWordPOS.WNdb = WNdb;\n/**\r\n * access to stopwords\r\n * @type {Array}\r\n */\n\nWordPOS.stopwords = stopwords;\nmodule.exports = WordPOS;","map":{"version":3,"sources":["/Users/tenzy/Documents/work/vata-hackathon-fe/atva/node_modules/wordpos/src/wordpos.js"],"names":["_","require","util","stopwords","words","stopwordsStr","makeStopwordString","WNdb","DataFile","IndexFile","normalize","word","toLowerCase","replace","join","isStopword","indexOf","tokenizer","str","split","prepText","text","isArray","deduped","uniq","options","reject","bind","isString","lookup","pos","callback","profile","start","Date","files","getFilesFor","args","index","then","result","data","synsetOffset","done","catch","results","Error","push","nextTick","is","_noprofile","record","get","isFn","parse","self","Promise","all","map","exec","call","collect","fn","apply","WordPOS","dictPath","defaults","isObject","path","nounIndex","verbIndex","adjIndex","advIndex","nounData","verbData","adjData","advData","init","wordposProto","prototype","methods","error","method","concat","err","getPOS","nouns","verbs","adjectives","adverbs","rest","matches","chain","values","flatten","value","difference","lookupAdjective","lookupAdverb","lookupNoun","lookupVerb","isAdjective","isAdverb","isNoun","isVerb","getAdjectives","getAdverbs","getNouns","getVerbs","seek","offset","Number","isNaN","msg","module","exports"],"mappings":"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","sourcesContent":["/*!\r\n* wordpos.js\r\n*\r\n*    Node.js part-of-speech utilities using WordNet database.\r\n*\r\n* Copyright (c) 2012-2016 mooster@42at.com\r\n* https://github.com/moos/wordpos\r\n*\r\n* Released under MIT license\r\n*/\r\n\r\nvar _ = require('underscore')._,\r\n  util = require('util'),\r\n  stopwords = require('../lib/natural/util/stopwords').words,\r\n  stopwordsStr = makeStopwordString(stopwords),\r\n  WNdb = require('wordnet-db'),\r\n  DataFile = require('./dataFile'),\r\n  IndexFile = require('./indexFile');\r\n\r\n\r\nfunction normalize(word) {\r\n  return word.toLowerCase().replace(/\\s+/g, '_');\r\n}\r\n\r\nfunction makeStopwordString(stopwords) {\r\n  return ' '+ stopwords.join(' ') +' ';\r\n}\r\n\r\nfunction isStopword(stopwords, word) {\r\n  return stopwords.indexOf(' '+word+' ') >= 0;\r\n}\r\n\r\nfunction tokenizer(str) {\r\n  return str.split(/\\W+/); //_.without(results,'',' ')\r\n}\r\n\r\nfunction prepText(text) {\r\n  if (_.isArray(text)) return text;\r\n  var deduped = _.uniq(tokenizer(text));\r\n  if (!this.options.stopwords) return deduped;\r\n  return _.reject(deduped, _.bind(isStopword, null,\r\n    _.isString(this.options.stopwords) ? this.options.stopwords : stopwordsStr\r\n  ));\r\n}\r\n\r\n/**\r\n * factory for main lookup function\r\n *\r\n * @param pos {string} - n/v/a/r\r\n * @returns {Function} - lookup function bound to POS\r\n */\r\nfunction lookup(pos) {\r\n  return function(word, callback) {\r\n    var profile = this.options.profile,\r\n      start = profile && new Date(),\r\n      files = this.getFilesFor(pos),\r\n      args = [];\r\n\r\n    word = normalize(word);\r\n\r\n    // lookup index\r\n    return files.index.lookup(word)\r\n      .then(function(result) {\r\n        if (result) {\r\n          // lookup data\r\n          return files.data.lookup(result.synsetOffset).then(done);\r\n        } else {\r\n          // not found in index\r\n          return done([]);\r\n        }\r\n      })\r\n      .catch(done);\r\n\r\n    function done(results) {\r\n      if (results instanceof Error) {\r\n        args.push([], word);\r\n      } else {\r\n        args.push(results, word);\r\n      }\r\n      //console.log(3333, args)\r\n      profile && args.push(new Date() - start);\r\n      nextTick(callback, args);\r\n      return results;\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * isX() factory function\r\n *\r\n * @param pos {string} - n/v/a/r\r\n * @returns {Function}\r\n */\r\nfunction is(pos){\r\n  return function(word, callback, _noprofile) {\r\n    // disable profiling when isX() used internally\r\n    var profile = this.options.profile && !_noprofile,\r\n      start = profile && new Date(),\r\n      args = [],\r\n      index = this.getFilesFor(pos).index;\r\n    word = normalize(word);\r\n\r\n    return index\r\n      .lookup(word)\r\n      .then(function(record) {\r\n        var result = !!record;\r\n        args.push(result, word);\r\n        profile && args.push(new Date() - start);\r\n        nextTick(callback, args);\r\n        return result;\r\n      });\r\n  };\r\n}\r\n\r\n\r\n/**\r\n * getX() factory function\r\n *\r\n * @param isFn {function} - an isX() function\r\n * @returns {Function}\r\n */\r\nfunction get(isFn) {\r\n  return function(text, callback, _noprofile) {\r\n    var profile = this.options.profile && !_noprofile,\r\n      start = profile && new Date(),\r\n      words = this.parse(text),\r\n      results = [],\r\n      self = this;\r\n\r\n    //if (!n) return (process.nextTick(done),0);\r\n    return Promise\r\n      .all(words.map(exec))\r\n      .then(done);\r\n\r\n    function exec(word) {\r\n      return self[isFn]\r\n        .call(self, word, null, /*_noprofile*/ true)\r\n        .then(function collect(result) {\r\n          result && results.push(word);\r\n        });\r\n    }\r\n\r\n    function done(){\r\n      var args = [results];\r\n      profile && args.push(new Date() - start);\r\n      nextTick(callback, args);\r\n      return results;\r\n    }\r\n  };\r\n}\r\n\r\n// setImmediate executes callback AFTER promise handlers.\r\n// Without it, exceptions in callback may be caught by Promise.\r\nfunction nextTick(fn, args) {\r\n  if (fn) {\r\n    fn.apply(null, args);\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @class WordPOS\r\n * @param options {object} -- @see WordPOS.defaults\r\n * @constructor\r\n */\r\nvar WordPOS = function(options) {\r\n  var dictPath;\r\n\r\n  this.options = _.defaults({}, _.isObject(options) && options || {}, {\r\n    dictPath: WNdb.path\r\n  }, WordPOS.defaults);\r\n\r\n  dictPath = this.options.dictPath;\r\n\r\n  this.nounIndex = new IndexFile(dictPath, 'noun');\r\n  this.verbIndex = new IndexFile(dictPath, 'verb');\r\n  this.adjIndex = new IndexFile(dictPath, 'adj');\r\n  this.advIndex = new IndexFile(dictPath, 'adv');\r\n\r\n  this.nounData = new DataFile(dictPath, 'noun');\r\n  this.verbData = new DataFile(dictPath, 'verb');\r\n  this.adjData = new DataFile(dictPath, 'adj');\r\n  this.advData = new DataFile(dictPath, 'adv');\r\n\r\n  // define randX() functions\r\n  require('./rand').init(this);\r\n\r\n  if (_.isArray(this.options.stopwords)) {\r\n    this.options.stopwords = makeStopwordString(this.options.stopwords);\r\n  }\r\n};\r\n\r\n\r\nWordPOS.defaults = {\r\n  /**\r\n   * path to WordNet data (override only if not using wordnet-db)\r\n   */\r\n  dictPath: '',\r\n\r\n  /**\r\n   * enable profiling, time in msec returned as second argument in callback\r\n   */\r\n  profile: false,\r\n\r\n  /**\r\n   * if true, exclude standard stopwords.\r\n   * if array, stopwords to exclude, eg, ['all','of','this',...]\r\n   * if false, do not filter any stopwords.\r\n   */\r\n  stopwords: true\r\n};\r\n\r\nvar wordposProto = WordPOS.prototype;\r\n\r\n/**\r\n * lookup a word in all indexes\r\n *\r\n * @param word {string} - search word\r\n * @param callback {Function} (optional) - callback with (results, word) signature\r\n * @returns {Promise}\r\n */\r\nwordposProto.lookup = function(word, callback) {\r\n  var self = this,\r\n    results = [],\r\n    profile = this.options.profile,\r\n    start = profile && new Date(),\r\n    methods = ['lookupAdverb', 'lookupAdjective', 'lookupVerb', 'lookupNoun'];\r\n\r\n  return Promise\r\n    .all(methods.map(exec))\r\n    .then(done)\r\n    .catch(error);\r\n\r\n  function exec(method) {\r\n    return self[ method ]\r\n      .call(self, word)\r\n      .then(function collect(result){\r\n        results = results.concat(result);\r\n      });\r\n  }\r\n\r\n  function done() {\r\n    var args = [results, word];\r\n    profile && args.push(new Date() - start);\r\n    nextTick(callback, args);\r\n    return results;\r\n  }\r\n\r\n  function error(err) {\r\n    nextTick(callback, [[], word]);\r\n    throw err;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * getPOS() - Find all POS for all words in given string\r\n *\r\n * @param text {string} - words to lookup for POS\r\n * @param callback {function} (optional) - receives object with words broken into POS or 'rest', ie,\r\n * \t    Object: {nouns:[], verbs:[], adjectives:[], adverbs:[], rest:[]}\r\n * @return Promise - resolve function receives data object\r\n */\r\nwordposProto.getPOS = function(text, callback) {\r\n  var self = this,\r\n    data = {nouns:[], verbs:[], adjectives:[], adverbs:[], rest:[]},\r\n    profile = this.options.profile,\r\n    start = profile && new Date(),\r\n    words = this.parse(text),\r\n    methods = ['getAdverbs', 'getAdjectives', 'getVerbs', 'getNouns'];\r\n\r\n  return Promise\r\n    .all(methods.map(exec))\r\n    .then(done)\r\n    .catch(error);\r\n\r\n  function exec(method) {\r\n    return self[ method ]\r\n      .call(self, text, null, true)\r\n      .then(function collect(results) {\r\n        // getAdjectives --> adjectives\r\n        var pos = method.replace('get','').toLowerCase();\r\n        data[ pos ] =  results;\r\n      });\r\n  }\r\n\r\n  function done() {\r\n    var matches = _(data).chain()\r\n      .values()\r\n      .flatten()\r\n      .uniq()\r\n      .value(),\r\n      args = [data];\r\n\r\n    data.rest =  _(words).difference(matches);\r\n\r\n    profile && args.push(new Date() - start);\r\n    nextTick(callback, args);\r\n    return data;\r\n  }\r\n\r\n  function error(err) {\r\n    nextTick(callback, []);\r\n    throw err;\r\n  }\r\n};\r\n\r\n/**\r\n * get index and data files for given pos\r\n *\r\n * @param pos {string} - n/v/a/r\r\n * @returns {object} - keys {index, data}\r\n */\r\nwordposProto.getFilesFor = function (pos) {\r\n  switch(pos) {\r\n    case 'n':\r\n      return {index: this.nounIndex, data: this.nounData};\r\n    case 'v':\r\n      return {index: this.verbIndex, data: this.verbData};\r\n    case 'a': case 's':\r\n    return {index: this.adjIndex, data: this.adjData};\r\n    case 'r':\r\n      return {index: this.advIndex, data: this.advData};\r\n  }\r\n  return {};\r\n};\r\n\r\n\r\n/**\r\n * lookupX() - Lookup word definition if already know POS\r\n * @see lookup\r\n */\r\nwordposProto.lookupAdjective = lookup('a');\r\nwordposProto.lookupAdverb = lookup('r');\r\nwordposProto.lookupNoun = lookup('n');\r\nwordposProto.lookupVerb = lookup('v');\r\n\r\n/**\r\n * isX() - Test if word is given POS\r\n * @see is\r\n */\r\nwordposProto.isAdjective = is('a');\r\nwordposProto.isAdverb = is('r');\r\nwordposProto.isNoun = is('n');\r\nwordposProto.isVerb = is('v');\r\n\r\n/**\r\n * getX() - Find all words in string that are given POS\r\n * @see get\r\n */\r\nwordposProto.getAdjectives = get('isAdjective');\r\nwordposProto.getAdverbs = get('isAdverb');\r\nwordposProto.getNouns = get('isNoun');\r\nwordposProto.getVerbs = get('isVerb');\r\n\r\n/**\r\n * parse - get deduped, less stopwords\r\n *\r\n * @param text {string|array} - string of words to parse.  If array is given, it is left in tact.\r\n * @returns {array}\r\n */\r\nwordposProto.parse = prepText;\r\n\r\n\r\n/**\r\n * seek - get record at offset for pos\r\n *\r\n * @param offset {number} - synset offset\r\n * @param pos {string} - POS a/r/n/v\r\n * @param callback {function} - optional callback\r\n * @returns Promise\r\n */\r\nwordposProto.seek = function(offset, pos, callback){\r\n  offset = Number(offset);\r\n  if (_.isNaN(offset) || offset <= 0) return error('offset must be valid positive number.');\r\n\r\n  var data = this.getFilesFor(pos).data;\r\n  if (!data) return error('Incorrect POS - 2nd argument must be a, r, n or v.');\r\n\r\n  return data.lookup(offset, callback);\r\n\r\n  function error(msg) {\r\n    var err = new Error(msg);\r\n    callback && callback(err, {});\r\n    return Promise.reject(err);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * access to WordNet DB\r\n * @type {object}\r\n */\r\nWordPOS.WNdb = WNdb;\r\n\r\n/**\r\n * access to stopwords\r\n * @type {Array}\r\n */\r\nWordPOS.stopwords = stopwords;\r\n\r\n\r\nmodule.exports = WordPOS;\r\n"]},"metadata":{},"sourceType":"script"}