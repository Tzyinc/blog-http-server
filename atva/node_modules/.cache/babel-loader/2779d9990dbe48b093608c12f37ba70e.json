{"ast":null,"code":"/*!\r\n * piper.js\r\n *\r\n *     executes multiple async i/o tasks and pools similar callbacks,\r\n *     calling i/o open/close when all incoming tasks are done.\r\n *\r\n * Copyright (c) 2012-2016 mooster@42at.com\r\n * https://github.com/moos/wordpos\r\n *\r\n * Released under MIT license\r\n */\nvar _ = require('underscore')._,\n    util = require('util'),\n    fs = require('fs');\n/**\r\n * run single 'task' method sharing callbacks.  Method MUST take callback as LAST arg.\r\n * piper is bound to an IndexFile.\r\n *\r\n * @param task {string} - task name unique to method!\r\n * @param method {function} - method to execute, gets (args, ... , callback)\r\n * @param args {Array} - args to pass to method\r\n * @param context {object} - other params to remember and sent to callback\r\n * @param callback {function} - result callback\r\n */\n\n\nfunction piper(task, method, args, context, callback) {\n  var readCallbacks = this.callbackQueue,\n      memoArgs = _.rest(arguments, 2),\n      wrappedCallback; //console.log('piper', task, [method]);\n  // queue up if already reading file for this task\n\n\n  if (task in readCallbacks) {\n    readCallbacks[task].push(memoArgs);\n    return;\n  }\n\n  readCallbacks[task] = [memoArgs];\n\n  if (!this.fd) {\n    //console.log(' ... opening', this.filePath);\n    this.fd = fs.openSync(this.filePath, 'r');\n  } // ref count so we know when to close the main index file\n\n\n  ++this.refcount;\n  wrappedCallback = _.partial(piper.wrapper, this, task); // call method -- replace original callback (last arg) with wrapped one\n\n  method.apply(null, [].concat(args, wrappedCallback));\n} // result is the *same* for same task\n\n\npiper.wrapper = function (self, task\n/*, result...*/\n) {\n  var readCallbacks = self.callbackQueue,\n      result = _.rest(arguments, 2),\n      callback,\n      args; // live access callbacks cache in case nested cb's\n  // add to the array.\n\n\n  while (args = readCallbacks[task].shift()) {\n    callback = args.pop(); // last arg MUST be callback\n    //    console.log('>>>> pper wrapper', self.fastIndex.name, task, result.toString())\n\n    callback.apply(null, [].concat(_.flatten(args,\n    /*shallow*/\n    true), result));\n  } // now done - delete cb cache\n\n\n  delete readCallbacks[task];\n\n  if (--self.refcount === 0) {\n    //console.log(' ... closing', self.filePath);\n    fs.closeSync(self.fd);\n    self.fd = null;\n  }\n};\n\nmodule.exports = piper;","map":{"version":3,"sources":["/Users/tenzy/Documents/work/vata-hackathon-fe/atva/node_modules/wordpos/src/piper.js"],"names":["_","require","util","fs","piper","task","method","args","context","callback","readCallbacks","callbackQueue","memoArgs","rest","arguments","wrappedCallback","push","fd","openSync","filePath","refcount","partial","wrapper","apply","concat","self","result","shift","pop","flatten","closeSync","module","exports"],"mappings":"AAAA;;;;;;;;;;;AAYA,IAAIA,CAAC,GAAGC,OAAO,CAAC,YAAD,CAAP,CAAsBD,CAA9B;AAAA,IACEE,IAAI,GAAGD,OAAO,CAAC,MAAD,CADhB;AAAA,IAEEE,EAAE,GAAGF,OAAO,CAAC,IAAD,CAFd;AAIA;;;;;;;;;;;;AAUA,SAASG,KAAT,CAAeC,IAAf,EAAqBC,MAArB,EAA6BC,IAA7B,EAAmCC,OAAnC,EAA4CC,QAA5C,EAAqD;AACnD,MAAIC,aAAa,GAAG,KAAKC,aAAzB;AAAA,MACEC,QAAQ,GAAGZ,CAAC,CAACa,IAAF,CAAOC,SAAP,EAAkB,CAAlB,CADb;AAAA,MAEEC,eAFF,CADmD,CAKlD;AAED;;;AACA,MAAIV,IAAI,IAAIK,aAAZ,EAA0B;AACxBA,IAAAA,aAAa,CAACL,IAAD,CAAb,CAAoBW,IAApB,CAAyBJ,QAAzB;AACA;AACD;;AACDF,EAAAA,aAAa,CAACL,IAAD,CAAb,GAAsB,CAACO,QAAD,CAAtB;;AAEA,MAAI,CAAC,KAAKK,EAAV,EAAc;AACZ;AACA,SAAKA,EAAL,GAAUd,EAAE,CAACe,QAAH,CAAY,KAAKC,QAAjB,EAA2B,GAA3B,CAAV;AACD,GAjBkD,CAmBnD;;;AACA,IAAE,KAAKC,QAAP;AAEAL,EAAAA,eAAe,GAAGf,CAAC,CAACqB,OAAF,CAAUjB,KAAK,CAACkB,OAAhB,EAAyB,IAAzB,EAA+BjB,IAA/B,CAAlB,CAtBmD,CAwBnD;;AACAC,EAAAA,MAAM,CAACiB,KAAP,CAAa,IAAb,EAAmB,GAAGC,MAAH,CAAWjB,IAAX,EAAiBQ,eAAjB,CAAnB;AACD,C,CAED;;;AACAX,KAAK,CAACkB,OAAN,GAAgB,UAASG,IAAT,EAAepB;AAAK;AAApB,EAAoC;AAClD,MAAIK,aAAa,GAAGe,IAAI,CAACd,aAAzB;AAAA,MACEe,MAAM,GAAG1B,CAAC,CAACa,IAAF,CAAOC,SAAP,EAAkB,CAAlB,CADX;AAAA,MAEEL,QAFF;AAAA,MAEYF,IAFZ,CADkD,CAKlD;AACA;;;AACA,SAAOA,IAAI,GAAGG,aAAa,CAACL,IAAD,CAAb,CAAoBsB,KAApB,EAAd,EAA2C;AACzClB,IAAAA,QAAQ,GAAGF,IAAI,CAACqB,GAAL,EAAX,CADyC,CAClB;AAE3B;;AACInB,IAAAA,QAAQ,CAACc,KAAT,CAAe,IAAf,EAAqB,GAAGC,MAAH,CAAUxB,CAAC,CAAC6B,OAAF,CAAUtB,IAAV;AAAgB;AAAW,QAA3B,CAAV,EAA4CmB,MAA5C,CAArB;AACD,GAZiD,CAclD;;;AACA,SAAOhB,aAAa,CAACL,IAAD,CAApB;;AAEA,MAAI,EAAEoB,IAAI,CAACL,QAAP,KAAoB,CAAxB,EAA2B;AACzB;AACAjB,IAAAA,EAAE,CAAC2B,SAAH,CAAaL,IAAI,CAACR,EAAlB;AACAQ,IAAAA,IAAI,CAACR,EAAL,GAAU,IAAV;AACD;AACF,CAtBD;;AAyBAc,MAAM,CAACC,OAAP,GAAiB5B,KAAjB","sourcesContent":["/*!\r\n * piper.js\r\n *\r\n *     executes multiple async i/o tasks and pools similar callbacks,\r\n *     calling i/o open/close when all incoming tasks are done.\r\n *\r\n * Copyright (c) 2012-2016 mooster@42at.com\r\n * https://github.com/moos/wordpos\r\n *\r\n * Released under MIT license\r\n */\r\n\r\nvar _ = require('underscore')._,\r\n  util = require('util'),\r\n  fs = require('fs');\r\n\r\n/**\r\n * run single 'task' method sharing callbacks.  Method MUST take callback as LAST arg.\r\n * piper is bound to an IndexFile.\r\n *\r\n * @param task {string} - task name unique to method!\r\n * @param method {function} - method to execute, gets (args, ... , callback)\r\n * @param args {Array} - args to pass to method\r\n * @param context {object} - other params to remember and sent to callback\r\n * @param callback {function} - result callback\r\n */\r\nfunction piper(task, method, args, context, callback){\r\n  var readCallbacks = this.callbackQueue,\r\n    memoArgs = _.rest(arguments, 2),\r\n    wrappedCallback;\r\n\r\n   //console.log('piper', task, [method]);\r\n\r\n  // queue up if already reading file for this task\r\n  if (task in readCallbacks){\r\n    readCallbacks[task].push(memoArgs);\r\n    return;\r\n  }\r\n  readCallbacks[task] = [memoArgs];\r\n\r\n  if (!this.fd) {\r\n    //console.log(' ... opening', this.filePath);\r\n    this.fd = fs.openSync(this.filePath, 'r');\r\n  }\r\n\r\n  // ref count so we know when to close the main index file\r\n  ++this.refcount;\r\n\r\n  wrappedCallback = _.partial(piper.wrapper, this, task);\r\n\r\n  // call method -- replace original callback (last arg) with wrapped one\r\n  method.apply(null, [].concat( args, wrappedCallback ));\r\n}\r\n\r\n// result is the *same* for same task\r\npiper.wrapper = function(self, task /*, result...*/){\r\n  var readCallbacks = self.callbackQueue,\r\n    result = _.rest(arguments, 2),\r\n    callback, args;\r\n\r\n  // live access callbacks cache in case nested cb's\r\n  // add to the array.\r\n  while (args = readCallbacks[task].shift()) {\r\n    callback = args.pop(); // last arg MUST be callback\r\n\r\n//    console.log('>>>> pper wrapper', self.fastIndex.name, task, result.toString())\r\n    callback.apply(null, [].concat(_.flatten(args, /*shallow*/true), result));\r\n  }\r\n\r\n  // now done - delete cb cache\r\n  delete readCallbacks[task];\r\n\r\n  if (--self.refcount === 0) {\r\n    //console.log(' ... closing', self.filePath);\r\n    fs.closeSync(self.fd);\r\n    self.fd = null;\r\n  }\r\n};\r\n\r\n\r\nmodule.exports = piper;\r\n\r\n"]},"metadata":{},"sourceType":"script"}