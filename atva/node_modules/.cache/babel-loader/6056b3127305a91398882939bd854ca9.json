{"ast":null,"code":"/*\n  Corpus class for parsing and analysing corpora\n  Copyright (C) 2018 Hugo W.L. ter Doest\n\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\nvar Sample = require('../../classifiers/maxent/Sample');\n\nvar ElementClass = require('../../classifiers/maxent/POS/POS_Element');\n\nvar Lexicon = require('./Lexicon');\n\nvar BROWN = 1; // sentences: an array of annotated sentences\n// A sentence is an array of annotated tokens\n// A token is an object with (token, tag, testTag, ruleList)\n\nfunction Corpus(data, typeOfCorpus, SentenceClass) {\n  this.wordCount = 0;\n  this.sentences = [];\n\n  if (data && typeOfCorpus) {\n    // For other types of corpora add a case here and supply a parsing method\n    switch (typeOfCorpus) {\n      case BROWN:\n        this.parseBrownCorpus(data, SentenceClass);\n        break;\n\n      default:\n        // Assume it is an array of tagged sentences\n        this.sentences = data;\n    }\n  }\n} // data is raw text\n// A corpus parsing method should split the corpus in sentences each of which\n// consist of an array of tokens.\n\n\nCorpus.prototype.parseBrownCorpus = function (data, SentenceClass) {\n  var that = this;\n  var lines = data.split('\\n');\n  lines.forEach(function (line) {\n    var trimmedLine = line.trim(); // Only parse lines that contain characters\n\n    if (trimmedLine != \"\") {\n      var taggedSentence = new SentenceClass();\n      var tokens = line.trim().split(/\\s+/);\n      tokens.forEach(function (token) {\n        that.wordCount++; // Create a tagged sentences consisting of tokens\n\n        var wordPlusTag = token.split('_');\n        taggedSentence.addTaggedWord(wordPlusTag[0], wordPlusTag[1]);\n      }); // Add the sentence to the corpus\n\n      that.sentences.push(taggedSentence);\n    }\n  });\n}; // Returns an array of all POS tags used in the corpus\n\n\nCorpus.prototype.getTags = function () {\n  return Object.keys(this.posTags);\n}; // Splits the corpus in a training and testing set.\n// percentageTrain is the size of the training corpus in percent\n// Returns an array with two elements: training corpus, testing corpus\n\n\nCorpus.prototype.splitInTrainAndTest = function (percentageTrain) {\n  var corpusTrain = new Corpus();\n  var corpusTest = new Corpus();\n  var p = percentageTrain / 100;\n  this.sentences.forEach(function (sentence, i) {\n    if (Math.random() < p) {\n      corpusTrain.sentences.push(sentence);\n    } else {\n      corpusTest.sentences.push(sentence);\n    }\n  });\n  return [corpusTrain, corpusTest];\n}; // Analyses the corpus:\n// - registers used POS tags\n// - records the frequency of POS tag for each word\n\n\nCorpus.prototype.analyse = function () {\n  this.tagFrequencies = {};\n  this.posTags = {};\n  this.wordCount = 0;\n  var that = this;\n  this.sentences.forEach(function (sentence) {\n    sentence.taggedWords.forEach(function (token) {\n      that.wordCount++; // Register the tags used in the corpus\n\n      that.posTags[token.tag] = true; // Register the frequency of the tag\n\n      if (!that.tagFrequencies[token.token]) {\n        that.tagFrequencies[token.token] = {};\n      }\n\n      if (!that.tagFrequencies[token.token][token.tag]) {\n        that.tagFrequencies[token.token][token.tag] = 0;\n      }\n\n      that.tagFrequencies[token.token][token.tag]++;\n    });\n  });\n}; // Creates a lexicon by taking the most frequently occurring tag of a word\n// as the right tag\n\n\nCorpus.prototype.buildLexicon = function () {\n  var lexicon = new Lexicon();\n  var that = this;\n  this.analyse();\n  Object.keys(this.tagFrequencies).forEach(function (token) {\n    var catToFreq = that.tagFrequencies[token];\n    var categories = Object.keys(catToFreq);\n\n    function compareByFrequency(a, b) {\n      if (catToFreq[a] > catToFreq[b]) {\n        return -1;\n      } else {\n        if (catToFreq[a] < catToFreq[b]) {\n          return 1;\n        } else {\n          return 0;\n        }\n      }\n    }\n\n    var sortedCategories = categories.sort(compareByFrequency);\n    lexicon.addWord(token, sortedCategories);\n  });\n  return lexicon;\n};\n\nCorpus.prototype.tag = function (lexicon) {\n  this.sentences.forEach(function (sentence) {\n    sentence.taggedWords.forEach(function (token) {\n      // tagWord returns a list of categories, take the first category\n      token.testTag = lexicon.tagWord(token.token)[0];\n    });\n  });\n};\n\nCorpus.prototype.nrSentences = function () {\n  return this.sentences.length;\n};\n\nCorpus.prototype.nrWords = function () {\n  return this.wordCount;\n};\n\nCorpus.prototype.generateFeatures = function () {\n  var features = [];\n  this.sentences.forEach(function (sentence) {\n    features = sentence.generateFeatures(features);\n  }); //console.log(JSON.stringify(features));\n\n  return features;\n};\n\nCorpus.prototype.prettyPrint = function () {\n  this.sentences.forEach(function (sentence, index) {//logger.debug(\"sentence no \" + index + \"\\n\" +\n    //  JSON.stringify(sentence, null, 2));\n  });\n};\n\nmodule.exports = Corpus;","map":{"version":3,"sources":["/Users/tenzy/Documents/work/vata-hackathon-fe/atva/node_modules/natural/lib/natural/brill_pos_tagger/lib/Corpus.js"],"names":["Sample","require","ElementClass","Lexicon","BROWN","Corpus","data","typeOfCorpus","SentenceClass","wordCount","sentences","parseBrownCorpus","prototype","that","lines","split","forEach","line","trimmedLine","trim","taggedSentence","tokens","token","wordPlusTag","addTaggedWord","push","getTags","Object","keys","posTags","splitInTrainAndTest","percentageTrain","corpusTrain","corpusTest","p","sentence","i","Math","random","analyse","tagFrequencies","taggedWords","tag","buildLexicon","lexicon","catToFreq","categories","compareByFrequency","a","b","sortedCategories","sort","addWord","testTag","tagWord","nrSentences","length","nrWords","generateFeatures","features","prettyPrint","index","module","exports"],"mappings":"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","sourcesContent":["/*\n  Corpus class for parsing and analysing corpora\n  Copyright (C) 2018 Hugo W.L. ter Doest\n\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nvar Sample = require('../../classifiers/maxent/Sample');\nvar ElementClass = require('../../classifiers/maxent/POS/POS_Element');\nvar Lexicon = require('./Lexicon');\n\nconst BROWN = 1;\n\n// sentences: an array of annotated sentences\n// A sentence is an array of annotated tokens\n// A token is an object with (token, tag, testTag, ruleList)\nfunction Corpus(data, typeOfCorpus, SentenceClass) {\n  this.wordCount = 0;\n  this.sentences = [];\n  if (data && typeOfCorpus) {\n    // For other types of corpora add a case here and supply a parsing method\n    switch (typeOfCorpus) {\n      case BROWN:\n        this.parseBrownCorpus(data, SentenceClass);\n        break;\n      default:\n        // Assume it is an array of tagged sentences\n        this.sentences = data;\n    }\n  }\n}\n\n// data is raw text\n// A corpus parsing method should split the corpus in sentences each of which\n// consist of an array of tokens.\nCorpus.prototype.parseBrownCorpus = function(data, SentenceClass) {\n  var that = this;\n\n  var lines = data.split('\\n');\n  lines.forEach(function(line) {\n    var trimmedLine = line.trim();\n    // Only parse lines that contain characters\n    if (trimmedLine != \"\") {\n      var taggedSentence = new SentenceClass();\n      var tokens = line.trim().split(/\\s+/);\n      tokens.forEach(function (token) {\n        that.wordCount++;\n        // Create a tagged sentences consisting of tokens\n        var wordPlusTag = token.split('_');\n        taggedSentence.addTaggedWord(wordPlusTag[0], wordPlusTag[1]);\n      });\n\n      // Add the sentence to the corpus\n      that.sentences.push(taggedSentence);\n    }\n  });\n};\n\n// Returns an array of all POS tags used in the corpus\nCorpus.prototype.getTags = function() {\n  return Object.keys(this.posTags);\n};\n\n// Splits the corpus in a training and testing set.\n// percentageTrain is the size of the training corpus in percent\n// Returns an array with two elements: training corpus, testing corpus\nCorpus.prototype.splitInTrainAndTest = function(percentageTrain) {\n  var corpusTrain = new Corpus();\n  var corpusTest = new Corpus();\n\n  var p = percentageTrain / 100;\n  this.sentences.forEach(function(sentence, i) {\n    if (Math.random() < p) {\n      corpusTrain.sentences.push(sentence);\n    }\n    else {\n      corpusTest.sentences.push(sentence);\n    }\n  });\n  return [corpusTrain, corpusTest];\n};\n\n// Analyses the corpus:\n// - registers used POS tags\n// - records the frequency of POS tag for each word\nCorpus.prototype.analyse = function() {\n  this.tagFrequencies = {};\n  this.posTags = {};\n  this.wordCount = 0;\n\n  var that = this;\n  this.sentences.forEach(function(sentence) {\n    sentence.taggedWords.forEach(function(token) {\n      that.wordCount++;\n\n      // Register the tags used in the corpus\n      that.posTags[token.tag] = true;\n\n      // Register the frequency of the tag\n      if (!that.tagFrequencies[token.token]) {\n        that.tagFrequencies[token.token] = {};\n      }\n      if (!that.tagFrequencies[token.token][token.tag]) {\n        that.tagFrequencies[token.token][token.tag] = 0;\n      }\n      that.tagFrequencies[token.token][token.tag]++;\n    });\n  });\n};\n\n// Creates a lexicon by taking the most frequently occurring tag of a word\n// as the right tag\nCorpus.prototype.buildLexicon = function() {\n  var lexicon = new Lexicon();\n  var that = this;\n\n  this.analyse();\n  Object.keys(this.tagFrequencies).forEach(function(token) {\n    var catToFreq = that.tagFrequencies[token];\n    var categories = Object.keys(catToFreq);\n\n    function compareByFrequency(a, b) {\n      if (catToFreq[a] > catToFreq[b]) {\n        return -1;\n      }\n      else {\n        if (catToFreq[a] < catToFreq[b]) {\n          return 1;\n        }\n        else {\n          return 0;\n        }\n      }\n    }\n\n    var sortedCategories = categories.sort(compareByFrequency);\n    lexicon.addWord(token, sortedCategories);\n  });\n  return lexicon;\n};\n\nCorpus.prototype.tag = function(lexicon) {\n  this.sentences.forEach(function(sentence) {\n    sentence.taggedWords.forEach(function(token) {\n      // tagWord returns a list of categories, take the first category\n      token.testTag = lexicon.tagWord(token.token)[0];\n    });\n  });\n};\n\nCorpus.prototype.nrSentences = function() {\n  return this.sentences.length;\n};\n\nCorpus.prototype.nrWords = function() {\n  return this.wordCount;\n};\n\nCorpus.prototype.generateFeatures = function() {\n  var features = [];\n  this.sentences.forEach(function(sentence) {\n    features = sentence.generateFeatures(features);\n  });\n  //console.log(JSON.stringify(features));\n  return features;\n};\n\nCorpus.prototype.prettyPrint = function() {\n  this.sentences.forEach(function(sentence, index) {\n    //logger.debug(\"sentence no \" + index + \"\\n\" +\n    //  JSON.stringify(sentence, null, 2));\n  });\n};\n\nmodule.exports = Corpus;\n"]},"metadata":{},"sourceType":"script"}