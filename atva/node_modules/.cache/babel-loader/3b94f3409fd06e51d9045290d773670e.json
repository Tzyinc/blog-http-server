{"ast":null,"code":"/*!\r\n * indexFile.js\r\n *\r\n * \t\timplements fast index lookup of WordNet's index files\r\n *\r\n * Copyright (c) 2012-2018 mooster@42at.com\r\n * https://github.com/moos/wordpos\r\n *\r\n * Portions: Copyright (c) 2011, Chris Umbel\r\n *\r\n * Released under MIT license\r\n */\nvar _ = require('underscore')._,\n    util = require('util'),\n    path = require('path'),\n    fs = require('fs'),\n    piper = require('./piper'),\n    KEY_LENGTH = 3;\n/**\r\n * load fast index bucket data\r\n *\r\n * @param dir {string} - dir path of index files\r\n * @param name {string} - name of index file, eg, 'index.verb'\r\n * @returns {Object} - fast index data object\r\n */\n\n\nfunction loadFastIndex(dir, name) {\n  var jsonFile = path.join(dir, 'fast-' + name + '.json'),\n      data = null;\n\n  try {\n    data = JSON.parse(fs.readFileSync(jsonFile, 'utf8')); //console.log('loaded %d buckets for %s', data.stats.buckets, data.name);\n  } catch (e) {\n    console.error('Error with fast index file. Try reinstalling from npm!');\n    throw e;\n  }\n\n  return data;\n}\n/**\r\n * read index file using fast index data at key\r\n *\r\n * @param key {string} - 3-char key into fast index\r\n * @param index {object} - index file object\r\n * @param callback {function} - function receives buffer of data read\r\n * @returns none\r\n */\n\n\nfunction readIndexForKey(key, index, callback) {\n  var data = index.fastIndex,\n      offset = data.offsets[key][0],\n      nextKey = data.offsets[key][1],\n      nextOffset = data.offsets[nextKey][0],\n      len = nextOffset - offset - 1,\n      buffer = new Buffer.alloc(len);\n  fs.read(index.fd, buffer, 0, len, offset, function (err, count) {\n    if (err) return console.log(err); //console.log('  read %d bytes for <%s>', count, key);\n\n    callback(buffer);\n  });\n}\n/**\r\n * read index file using fast index data at keyStart to keyEnd (inclusive)\r\n *\r\n * @param keyStart {string} - 3-char key into fast index to begin at\r\n * @param keyEnd {string|null} - 3-char key into fast index to end at.  If null, reads to next key.\r\n * @param index {object} - index file object\r\n * @param callback - function receives buffer of data read\r\n * @returns none\r\n */\n\n\nfunction readIndexBetweenKeys(keyStart, keyEnd, index, callback) {\n  var data = index.fastIndex,\n      offset = data.offsets[keyStart][0],\n      end = keyEnd || keyStart,\n      nextKey = data.offsets[end][1],\n      nextOffset = data.offsets[nextKey][0],\n      len = nextOffset - offset - 1,\n      buffer = new Buffer.alloc(len); //console.log('### readIndexBetweenKeys', keyStart, keyEnd, nextKey, len)\n\n  fs.read(index.fd, buffer, 0, len, offset, function (err, count) {\n    if (err) return console.log(err); // console.log('  read %d bytes for <%s>', count, keyStart);\n\n    callback(buffer);\n  });\n}\n/**\r\n * find a search term in an index file (using fast index)\r\n *\r\n * Calls to same bucket are queued for callback using the piper.\r\n *\r\n * @param search {string} - word to search for\r\n * @param callback {function} - callback receives found line and tokens\r\n * @returns none\r\n */\n\n\nfunction find(search, callback) {\n  var self = this,\n      data = this.fastIndex,\n      readCallbacks = this.callbackQueue,\n      miss = {\n    status: 'miss'\n  };\n  var key = search.slice(0, KEY_LENGTH);\n  if (!(key in data.offsets)) return process.nextTick(function () {\n    callback(miss);\n  }); // prepare the piper\n\n  var task = 'find:' + key,\n      args = [key, this],\n      context = [search, callback]; // last arg MUST be callback\n  // pay the piper\n\n  this.piper(task, readIndexForKey, args, context, collector);\n\n  function collector(_key, index, search, callback, buffer) {\n    var lines = buffer.toString().split('\\n'),\n        keys = lines.map(function (line) {\n      return line.substring(0, line.indexOf(' '));\n    }),\n        ind = _.indexOf(keys, search,\n    /*isSorted*/\n    true); // binary search!\n    //console.log(' %s is %d', search, ind);\n\n\n    if (ind === -1) return callback(miss);\n    var tokens = lines[ind].split(/\\s+/),\n        key = tokens[0],\n        result = {\n      status: 'hit',\n      key: key,\n      'line': lines[ind],\n      tokens: tokens\n    };\n    callback(result);\n  }\n}\n/**\r\n * find a word and prepare its lexical record\r\n *\r\n * @param word {string} - search word\r\n * @param callback {function} - callback function receives result\r\n * @returns none\r\n *\r\n * Credit for this routine to https://github.com/NaturalNode/natural\r\n */\n\n\nfunction lookup(word, callback) {\n  var self = this;\n  return new Promise(function (resolve, reject) {\n    self.find(word, function (record) {\n      var indexRecord = null,\n          i;\n\n      if (record.status == 'hit') {\n        var ptrs = [],\n            offsets = [];\n\n        for (i = 0; i < parseInt(record.tokens[3]); i++) {\n          ptrs.push(record.tokens[i]);\n        }\n\n        for (i = 0; i < parseInt(record.tokens[2]); i++) {\n          offsets.push(parseInt(record.tokens[ptrs.length + 6 + i], 10));\n        }\n\n        indexRecord = {\n          lemma: record.tokens[0],\n          pos: record.tokens[1],\n          ptrSymbol: ptrs,\n          senseCnt: parseInt(record.tokens[ptrs.length + 4], 10),\n          tagsenseCnt: parseInt(record.tokens[ptrs.length + 5], 10),\n          synsetOffset: offsets\n        };\n      }\n\n      callback && callback(indexRecord);\n      resolve(indexRecord);\n    });\n  });\n}\n/**\r\n * loads fast index data and return fast index find function\r\n *\r\n * @param index {object} - the IndexFile instance\r\n */\n\n\nfunction initIndex(index) {\n  var key = index.filePath,\n      data;\n\n  if (!(key in cache)) {\n    data = loadFastIndex(index.dictPath, index.fileName);\n    cache[key] = data;\n  } // if no fast index data was found or was corrupt, throw\n\n\n  if (!cache[key]) throw new Error('Unable to load fastIndex file: ' + index.filePath);\n  index.fastIndex = cache[key];\n  index.fastIndex.indexKeys = Object.keys(index.fastIndex.offsets);\n  index.fastIndex.trie = null; // calc on demand\n\n  index.refcount = 0;\n  index.callbackQueue = {};\n  index.piper = _.bind(piper, index);\n}\n/**\r\n * IndexFile class\r\n *\r\n * @param dictPath {string} - WordNet db dict path\r\n * @param name {string} - name of index: noun, verb, adj, adv\r\n * @constructor\r\n */\n\n\nvar IndexFile = function IndexFile(dictPath, name) {\n  this.dictPath = dictPath;\n  this.fileName = 'index.' + name;\n  this.filePath = path.join(this.dictPath, this.fileName);\n  initIndex(this);\n};\n\nIndexFile.prototype.lookup = lookup;\nIndexFile.prototype.find = find;\n/**\r\n * export static method\r\n * @type {readIndexBetweenKeys}\r\n */\n\nIndexFile.readIndexBetweenKeys = readIndexBetweenKeys;\n/**\r\n * cache of fast index data across instances of WordPOS class\r\n *\r\n * @type {object}\r\n */\n\nvar cache = {};\nmodule.exports = IndexFile;","map":{"version":3,"sources":["/Users/tenzy/Documents/work/vata-hackathon-fe/atva/node_modules/wordpos/src/indexFile.js"],"names":["_","require","util","path","fs","piper","KEY_LENGTH","loadFastIndex","dir","name","jsonFile","join","data","JSON","parse","readFileSync","e","console","error","readIndexForKey","key","index","callback","fastIndex","offset","offsets","nextKey","nextOffset","len","buffer","Buffer","alloc","read","fd","err","count","log","readIndexBetweenKeys","keyStart","keyEnd","end","find","search","self","readCallbacks","callbackQueue","miss","status","slice","process","nextTick","task","args","context","collector","_key","lines","toString","split","keys","map","line","substring","indexOf","ind","tokens","result","lookup","word","Promise","resolve","reject","record","indexRecord","i","ptrs","parseInt","push","length","lemma","pos","ptrSymbol","senseCnt","tagsenseCnt","synsetOffset","initIndex","filePath","cache","dictPath","fileName","Error","indexKeys","Object","trie","refcount","bind","IndexFile","prototype","module","exports"],"mappings":"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","sourcesContent":["/*!\r\n * indexFile.js\r\n *\r\n * \t\timplements fast index lookup of WordNet's index files\r\n *\r\n * Copyright (c) 2012-2018 mooster@42at.com\r\n * https://github.com/moos/wordpos\r\n *\r\n * Portions: Copyright (c) 2011, Chris Umbel\r\n *\r\n * Released under MIT license\r\n */\r\n\r\nvar _ = require('underscore')._,\r\n  util = require('util'),\r\n  path = require('path'),\r\n  fs = require('fs'),\r\n  piper = require('./piper'),\r\n  KEY_LENGTH = 3;\r\n\r\n\r\n/**\r\n * load fast index bucket data\r\n *\r\n * @param dir {string} - dir path of index files\r\n * @param name {string} - name of index file, eg, 'index.verb'\r\n * @returns {Object} - fast index data object\r\n */\r\nfunction loadFastIndex(dir, name) {\r\n  var jsonFile = path.join(dir, 'fast-' + name + '.json'),\r\n    data = null;\r\n  try{\r\n    data = JSON.parse( fs.readFileSync(jsonFile,'utf8') );\r\n    //console.log('loaded %d buckets for %s', data.stats.buckets, data.name);\r\n  } catch(e) {\r\n    console.error('Error with fast index file. Try reinstalling from npm!');\r\n    throw e;\r\n  }\r\n  return data;\r\n}\r\n\r\n/**\r\n * read index file using fast index data at key\r\n *\r\n * @param key {string} - 3-char key into fast index\r\n * @param index {object} - index file object\r\n * @param callback {function} - function receives buffer of data read\r\n * @returns none\r\n */\r\nfunction readIndexForKey(key, index, callback) {\r\n  var data = index.fastIndex,\r\n    offset = data.offsets[key][0],\r\n    nextKey = data.offsets[key][1],\r\n    nextOffset = data.offsets[nextKey][0],\r\n    len = nextOffset - offset - 1,\r\n    buffer = new Buffer.alloc(len);\r\n\r\n  fs.read(index.fd, buffer, 0, len, offset, function(err, count){\r\n     if (err) return console.log(err);\r\n     //console.log('  read %d bytes for <%s>', count, key);\r\n     callback(buffer);\r\n  });\r\n}\r\n\r\n\r\n/**\r\n * read index file using fast index data at keyStart to keyEnd (inclusive)\r\n *\r\n * @param keyStart {string} - 3-char key into fast index to begin at\r\n * @param keyEnd {string|null} - 3-char key into fast index to end at.  If null, reads to next key.\r\n * @param index {object} - index file object\r\n * @param callback - function receives buffer of data read\r\n * @returns none\r\n */\r\nfunction readIndexBetweenKeys(keyStart, keyEnd, index, callback) {\r\n  var data = index.fastIndex,\r\n    offset = data.offsets[keyStart][0],\r\n    end = keyEnd || keyStart,\r\n    nextKey = data.offsets[end][1],\r\n    nextOffset = data.offsets[nextKey][0],\r\n    len = nextOffset - offset - 1,\r\n    buffer = new Buffer.alloc(len);\r\n\r\n  //console.log('### readIndexBetweenKeys', keyStart, keyEnd, nextKey, len)\r\n  fs.read(index.fd, buffer, 0, len, offset, function(err, count){\r\n     if (err) return console.log(err);\r\n     // console.log('  read %d bytes for <%s>', count, keyStart);\r\n     callback(buffer);\r\n  });\r\n}\r\n\r\n/**\r\n * find a search term in an index file (using fast index)\r\n *\r\n * Calls to same bucket are queued for callback using the piper.\r\n *\r\n * @param search {string} - word to search for\r\n * @param callback {function} - callback receives found line and tokens\r\n * @returns none\r\n */\r\nfunction find(search, callback) {\r\n  var self = this,\r\n    data = this.fastIndex,\r\n    readCallbacks = this.callbackQueue,\r\n    miss = {status: 'miss'};\r\n\r\n  var key = search.slice(0, KEY_LENGTH);\r\n  if (!(key in data.offsets)) return process.nextTick(function(){ callback(miss) });\r\n\r\n  // prepare the piper\r\n  var task = 'find:' + key,\r\n    args = [key, this],\r\n    context = [search, callback]; // last arg MUST be callback\r\n\r\n  // pay the piper\r\n  this.piper(task, readIndexForKey, args, context, collector);\r\n\r\n  function collector(_key, index, search, callback, buffer){\r\n    var lines = buffer.toString().split('\\n'),\r\n      keys = lines.map(function(line){\r\n        return line.substring(0,line.indexOf(' '));\r\n      }),\r\n      ind = _.indexOf(keys, search, /*isSorted*/ true);\t// binary search!\r\n\r\n    //console.log(' %s is %d', search, ind);\r\n    if (ind === -1) return callback(miss);\r\n\r\n    var tokens = lines[ind].split(/\\s+/),\r\n      key = tokens[0],\r\n      result = {status: 'hit', key: key, 'line': lines[ind], tokens: tokens};\r\n\r\n    callback(result);\r\n  }\r\n}\r\n\r\n/**\r\n * find a word and prepare its lexical record\r\n *\r\n * @param word {string} - search word\r\n * @param callback {function} - callback function receives result\r\n * @returns none\r\n *\r\n * Credit for this routine to https://github.com/NaturalNode/natural\r\n */\r\nfunction lookup(word, callback) {\r\n  var self = this;\r\n\r\n  return new Promise(function(resolve, reject){\r\n    self.find(word, function (record) {\r\n      var indexRecord = null,\r\n        i;\r\n\r\n      if (record.status == 'hit') {\r\n        var ptrs = [], offsets = [];\r\n\r\n        for (i = 0; i < parseInt(record.tokens[3]); i++)\r\n          ptrs.push(record.tokens[i]);\r\n\r\n        for (i = 0; i < parseInt(record.tokens[2]); i++)\r\n          offsets.push(parseInt(record.tokens[ptrs.length + 6 + i], 10));\r\n\r\n        indexRecord = {\r\n          lemma       : record.tokens[0],\r\n          pos         : record.tokens[1],\r\n          ptrSymbol   : ptrs,\r\n          senseCnt    : parseInt(record.tokens[ptrs.length + 4], 10),\r\n          tagsenseCnt : parseInt(record.tokens[ptrs.length + 5], 10),\r\n          synsetOffset: offsets\r\n        };\r\n      }\r\n\r\n      callback && callback(indexRecord);\r\n      resolve(indexRecord);\r\n    });\r\n  });\r\n}\r\n\r\n\r\n/**\r\n * loads fast index data and return fast index find function\r\n *\r\n * @param index {object} - the IndexFile instance\r\n */\r\nfunction initIndex(index){\r\n  var key = index.filePath,\r\n    data;\r\n\r\n  if (!(key in cache)) {\r\n    data = loadFastIndex(index.dictPath, index.fileName);\r\n    cache[key] = data;\r\n  }\r\n\r\n  // if no fast index data was found or was corrupt, throw\r\n  if (!cache[key]) throw new Error('Unable to load fastIndex file: ' + index.filePath);\r\n\r\n  index.fastIndex = cache[key];\r\n  index.fastIndex.indexKeys = Object.keys(index.fastIndex.offsets);\r\n  index.fastIndex.trie = null;  // calc on demand\r\n\r\n  index.refcount = 0;\r\n  index.callbackQueue = {};\r\n  index.piper = _.bind(piper, index);\r\n}\r\n\r\n/**\r\n * IndexFile class\r\n *\r\n * @param dictPath {string} - WordNet db dict path\r\n * @param name {string} - name of index: noun, verb, adj, adv\r\n * @constructor\r\n */\r\nvar IndexFile = function(dictPath, name) {\r\n  this.dictPath = dictPath;\r\n  this.fileName = 'index.' + name;\r\n  this.filePath = path.join(this.dictPath, this.fileName);\r\n  initIndex(this);\r\n};\r\n\r\nIndexFile.prototype.lookup = lookup;\r\nIndexFile.prototype.find = find;\r\n\r\n/**\r\n * export static method\r\n * @type {readIndexBetweenKeys}\r\n */\r\nIndexFile.readIndexBetweenKeys = readIndexBetweenKeys;\r\n\r\n/**\r\n * cache of fast index data across instances of WordPOS class\r\n *\r\n * @type {object}\r\n */\r\nvar cache = {};\r\n\r\n\r\n\r\nmodule.exports = IndexFile;\r\n"]},"metadata":{},"sourceType":"script"}