{"ast":null,"code":"import { SummarizerManager } from \"node-summarizer\";\nimport { TfIdf } from \"natural\";\nimport jsonpack from \"jsonpack/main\";\nlet fakeServerJson = {};\nlet workingFileHash = \"\";\n/**\n * @typedef {Object} DocumentHash\n * @property {string} doc_hash\n */\n\n/**\n * creates a document and returns a :\"hash\".\n * \n * @param {string}   documentTitle\n * @return {DocumentHash} document hash\n */\n\nexport function initUrlDocument(documentObj) {\n  fakeServerJson = documentObj;\n  workingFileHash = Object.keys(documentObj)[0];\n}\n/**\n * @typedef {Object} DocumentHash\n * @property {string} doc_hash\n */\n\n/**\n * creates a document and returns a :\"hash\".\n * \n * @param {string}   documentTitle\n * @return {DocumentHash} document hash\n */\n\nexport function createDocument(documentTitle) {\n  console.log('createDocument');\n  fakeServerJson[documentTitle] = {\n    title: documentTitle,\n    doc_hash: documentTitle\n  };\n  workingFileHash = documentTitle;\n  return new Promise(function (resolve, reject) {\n    resolve(fakeServerJson[documentTitle]);\n  });\n}\n/**\n * @typedef {Object} DocumentDetails\n * @property {Array.<Section>} Sections\n * @property {string} doc_hash\n * @property {string} title\n */\n\n/**\n* @typedef {Object} Section\n* @property {number} id\n* @property {string} summary\n* @property {string} text\n* @property {number} timestamp\n* @property {Array.<string>} tags\n*/\n\n/**\n * given a hash, return the document\n *\n * @param {string}   documentHash\n * @return {DocumentDetails} \n */\n\nexport function getDocument(documentHash) {\n  console.log('getDocument');\n  workingFileHash = documentHash;\n  return new Promise(function (resolve, reject) {\n    resolve(fakeServerJson[documentHash]);\n  });\n}\n/**\n* @typedef {Object} GeneratedSection\n* @property {number} id\n* @property {number} timestamp\n*/\n\n/**\n * given a hash, return the document\n *\n * @param {string}   documentHash\n * @return {GeneratedSection}\n */\n\nexport function createSection(documentHash) {\n  workingFileHash = documentHash;\n  let currDocument = fakeServerJson[documentHash];\n  let section = {\n    timestamp: new Date().getTime()\n  };\n\n  if (currDocument && currDocument.sections) {\n    section.id = currDocument.sections.length;\n    currDocument.sections.push(section);\n  } else {\n    if (!currDocument) {\n      fakeServerJson[documentHash] = {\n        title: documentHash,\n        doc_hash: documentHash\n      };\n    }\n\n    currDocument = fakeServerJson[documentHash];\n    section.id = 0;\n    currDocument.sections = [section];\n  }\n\n  return new Promise(function (resolve, reject) {\n    resolve(section);\n  });\n}\n/**\n* @typedef {Object} GeneratedSummary\n* @property {string} summary\n*/\n\n/**\n * change the text in a given section\n *\n * @param {number}   sectionId\n * @param {string}   text\n * @return {GeneratedSummary}\n */\n\nexport function setText(sectionId, text) {\n  let currDocument = fakeServerJson[workingFileHash];\n\n  if (currDocument && currDocument.sections) {\n    if (!currDocument.sections[sectionId]) {\n      let section = {\n        timestamp: new Date().getTime(),\n        id: currDocument.sections.length\n      };\n      currDocument.sections.push(section);\n    }\n\n    currDocument.sections[sectionId].text = text;\n\n    if (text) {\n      let Summarizer = new SummarizerManager(text, 1);\n      let summary = Summarizer.getSummaryByFrequency().summary;\n      currDocument.sections[sectionId].summary = Object.keys(summary).length === 0 && summary.constructor === Object ? \"\" : summary;\n    }\n\n    const packedJSON = jsonpack.pack(fakeServerJson);\n    window.history.pushState(\"\", \"\", `?d=${packedJSON}`);\n    return new Promise(function (resolve, reject) {\n      resolve(currDocument.sections[sectionId]);\n    });\n  }\n\n  return new Promise(function (resolve, reject) {\n    reject({\n      Error: \"something wrong setText\"\n    });\n  });\n}\n/**\n * change the tag in a given section\n *\n * @param {number}   sectionId\n * @param {Array.<string}   tags\n */\n\nexport function setTags(sectionId, tags) {\n  let currDocument = fakeServerJson[workingFileHash];\n\n  if (currDocument && currDocument.sections && currDocument.sections[sectionId] && currDocument.sections[sectionId].tags) {\n    currDocument.sections[sectionId].tags = tags;\n    return new Promise(function (resolve, reject) {\n      resolve();\n    });\n  }\n\n  return new Promise(function (resolve, reject) {\n    reject({\n      Error: \"something wrong setTags\"\n    });\n  });\n}\n/**\n * delete the given section\n *\n * @param {number}   sectionId\n */\n\nexport function deleteSection(sectionId) {\n  let currDocument = fakeServerJson[workingFileHash];\n\n  if (currDocument && currDocument.sections && currDocument.sections[sectionId]) {\n    currDocument.sections = currDocument.sections.filter(item => item.id !== sectionId);\n    return new Promise(function (resolve, reject) {\n      resolve();\n    });\n  }\n\n  return new Promise(function (resolve, reject) {\n    reject({\n      Error: \"something wrong deleteSection\"\n    });\n  });\n}\n/**\n* @typedef {Object} Section\n* @property {number} timestamp\n* @property {number} id\n* @property {string} text\n* @property {string} summary\n* @property {Array<string>>} tags\n*/\n\n/**\n* @typedef {Object} FullDocument\n* @property {Array<Section>} Sections\n* @property {string} title\n* @property {string} doc_hash\n*/\n\n/**\n * change the text in a given section\n *\n * @param {string}   documentHash\n * @return {FullDocument}\n */\n\nexport function generateTags(documentHash) {\n  let currDocument = fakeServerJson[documentHash];\n  let tfidf = new TfIdf();\n  let sections = currDocument.sections;\n\n  for (let section of sections) {\n    tfidf.addDocument(section.text || \"\");\n  }\n\n  for (let index in sections) {\n    let allTerms = tfidf.listTerms(index).sort((a, b) => b.tfidf - a.tfidf);\n    let tagsForSection = allTerms.map(item => item.term).slice(0, 5);\n    sections[index].tags = tagsForSection;\n  }\n\n  const packedJSON = jsonpack.pack(fakeServerJson);\n  window.history.pushState(\"\", \"\", `?d=${packedJSON}`);\n  return new Promise(function (resolve, reject) {\n    resolve(currDocument);\n  });\n}","map":{"version":3,"sources":["/Users/tenzy/Documents/work/vata-hackathon-fe/atva/src/utils/fetch.js"],"names":["SummarizerManager","TfIdf","jsonpack","fakeServerJson","workingFileHash","initUrlDocument","documentObj","Object","keys","createDocument","documentTitle","console","log","title","doc_hash","Promise","resolve","reject","getDocument","documentHash","createSection","currDocument","section","timestamp","Date","getTime","sections","id","length","push","setText","sectionId","text","Summarizer","summary","getSummaryByFrequency","constructor","packedJSON","pack","window","history","pushState","Error","setTags","tags","deleteSection","filter","item","generateTags","tfidf","addDocument","index","allTerms","listTerms","sort","a","b","tagsForSection","map","term","slice"],"mappings":"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","sourcesContent":["import { SummarizerManager } from \"node-summarizer\";\nimport { TfIdf } from \"natural\";\nimport jsonpack from \"jsonpack/main\";\n\nlet fakeServerJson = {};\nlet workingFileHash =\"\";\n\n/**\n * @typedef {Object} DocumentHash\n * @property {string} doc_hash\n */\n\n/**\n * creates a document and returns a :\"hash\".\n * \n * @param {string}   documentTitle\n * @return {DocumentHash} document hash\n */\nexport function initUrlDocument(documentObj) {\n  fakeServerJson = documentObj;\n  workingFileHash = Object.keys(documentObj)[0];\n}\n\n\n/**\n * @typedef {Object} DocumentHash\n * @property {string} doc_hash\n */\n\n/**\n * creates a document and returns a :\"hash\".\n * \n * @param {string}   documentTitle\n * @return {DocumentHash} document hash\n */\nexport function createDocument(documentTitle) {\n  console.log('createDocument')\n  fakeServerJson[documentTitle] = { title: documentTitle, doc_hash: documentTitle };\n  workingFileHash = documentTitle;\n\n  return new Promise(function (resolve, reject) {\n    resolve(fakeServerJson[documentTitle]);\n  });\n}\n\n\n/**\n * @typedef {Object} DocumentDetails\n * @property {Array.<Section>} Sections\n * @property {string} doc_hash\n * @property {string} title\n */\n\n/**\n* @typedef {Object} Section\n* @property {number} id\n* @property {string} summary\n* @property {string} text\n* @property {number} timestamp\n* @property {Array.<string>} tags\n*/\n\n/**\n * given a hash, return the document\n *\n * @param {string}   documentHash\n * @return {DocumentDetails} \n */\nexport function getDocument(documentHash) {\n\n  console.log('getDocument')\n  workingFileHash = documentHash\n  return new Promise(function (resolve, reject) {\n    resolve(fakeServerJson[documentHash]);\n  });\n}\n\n\n/**\n* @typedef {Object} GeneratedSection\n* @property {number} id\n* @property {number} timestamp\n*/\n\n/**\n * given a hash, return the document\n *\n * @param {string}   documentHash\n * @return {GeneratedSection}\n */\nexport function createSection(documentHash) {\n  workingFileHash = documentHash\n  let currDocument = fakeServerJson[documentHash];\n  let section = {\n    timestamp: new Date().getTime()\n  }\n\n  if (currDocument && currDocument.sections) {\n    section.id = currDocument.sections.length;\n    currDocument.sections.push(section)\n  } else {\n    if (!currDocument) {\n      fakeServerJson[documentHash] = { title: documentHash, doc_hash: documentHash };\n    }\n    currDocument = fakeServerJson[documentHash];\n    section.id = 0;\n    currDocument.sections = [section];\n  }\n\n  return new Promise(function (resolve, reject) {\n    resolve(section);\n  });\n}\n\n\n/**\n* @typedef {Object} GeneratedSummary\n* @property {string} summary\n*/\n\n/**\n * change the text in a given section\n *\n * @param {number}   sectionId\n * @param {string}   text\n * @return {GeneratedSummary}\n */\nexport function setText(sectionId, text) {\n  let currDocument = fakeServerJson[workingFileHash];\n\n  if (\n    currDocument &&\n    currDocument.sections\n  ) {\n    if (\n      !currDocument.sections[sectionId]\n    ) {\n      let section = {\n        timestamp: new Date().getTime(),\n        id: currDocument.sections.length,\n      }\n      currDocument.sections.push(section);\n    }\n\n    currDocument.sections[sectionId].text = text\n\n    if (text) {\n      let Summarizer = new SummarizerManager(text, 1); \n      let summary = Summarizer.getSummaryByFrequency().summary;\n      \n      currDocument.sections[sectionId].summary = Object.keys(summary).length === 0 && summary.constructor === Object ? \"\" : summary;\n    }\n\n    const packedJSON = jsonpack.pack(fakeServerJson);\n    window.history.pushState(\"\", \"\", `?d=${packedJSON}`);\n    return new Promise(function (resolve, reject) {\n      resolve(\n        currDocument.sections[sectionId]\n      );\n    });\n  }\n\n  return new Promise(function (resolve, reject) {\n    reject({ Error: \"something wrong setText\"});\n  });\n}\n\n/**\n * change the tag in a given section\n *\n * @param {number}   sectionId\n * @param {Array.<string}   tags\n */\nexport function setTags(sectionId, tags) {\n  let currDocument = fakeServerJson[workingFileHash];\n\n  if (\n    currDocument &&\n    currDocument.sections &&\n    currDocument.sections[sectionId] &&\n    currDocument.sections[sectionId].tags\n  ) {\n    currDocument.sections[sectionId].tags = tags\n    return new Promise(function (resolve, reject) {\n      resolve();\n    });\n  }\n\n  return new Promise(function (resolve, reject) {\n    reject({ Error: \"something wrong setTags\" });\n  });\n}\n\n\n/**\n * delete the given section\n *\n * @param {number}   sectionId\n */\nexport function deleteSection(sectionId) {\n  let currDocument = fakeServerJson[workingFileHash];\n\n  if (\n    currDocument &&\n    currDocument.sections &&\n    currDocument.sections[sectionId]\n  ) {\n    currDocument.sections = currDocument.sections.filter(item => item.id !== sectionId)\n    \n    return new Promise(function (resolve, reject) {\n      resolve();\n    });\n  }\n\n  return new Promise(function (resolve, reject) {\n    reject({ Error: \"something wrong deleteSection\" });\n  });\n\n}\n\n/**\n* @typedef {Object} Section\n* @property {number} timestamp\n* @property {number} id\n* @property {string} text\n* @property {string} summary\n* @property {Array<string>>} tags\n*/\n\n/**\n* @typedef {Object} FullDocument\n* @property {Array<Section>} Sections\n* @property {string} title\n* @property {string} doc_hash\n*/\n\n/**\n * change the text in a given section\n *\n * @param {string}   documentHash\n * @return {FullDocument}\n */\nexport function generateTags(documentHash) {\n  let currDocument = fakeServerJson[documentHash];\n\n  let tfidf = new TfIdf();\n\n  let { sections } = currDocument;\n  for (let section of sections) {\n    tfidf.addDocument(section.text || \"\");\n  }\n\n\n  for (let index in sections) {\n    let allTerms = tfidf.listTerms(index).sort((a, b) => b.tfidf-a.tfidf);\n    let tagsForSection = allTerms.map(item => item.term).slice(0, 5);\n    sections[index].tags = tagsForSection;\n  }\n  const packedJSON = jsonpack.pack(fakeServerJson);\n  window.history.pushState(\"\", \"\", `?d=${packedJSON}`);\n\n  return new Promise(function (resolve, reject) {\n    resolve(currDocument);\n  });\n}\n"]},"metadata":{},"sourceType":"module"}