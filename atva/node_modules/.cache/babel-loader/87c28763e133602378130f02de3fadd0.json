{"ast":null,"code":"/*!\r\n * rand.js\r\n *\r\n * \t\tdefine rand() and randX() functions on wordpos\r\n *\r\n * Copyright (c) 2012-2016 mooster@42at.com\r\n * https://github.com/moos/wordpos\r\n *\r\n * Released under MIT license\r\n */\nvar _ = require('underscore')._,\n    util = require('util'),\n    Trie = require('../lib/natural/trie/trie'),\n    IndexFile = require('./indexFile'),\n    KEY_LENGTH = 3;\n/**\r\n * factory function for randX()\r\n *\r\n * @param pos {string} - a,r,n,v\r\n * @returns {Function} - rand function bound to an index file\r\n */\n\n\nfunction makeRandX(pos) {\n  return function (opts, callback, _noprofile) {\n    // disable profiling when isX() used internally\n    var profile = this.options.profile && !_noprofile,\n        start = profile && new Date(),\n        args = [],\n        index = this.getFilesFor(pos).index,\n        startsWith = opts && opts.startsWith || '',\n        count = opts && opts.count || 1;\n\n    if (typeof opts === 'function') {\n      callback = opts;\n    }\n\n    return index.rand(startsWith, count, function (record) {\n      args.push(record, startsWith);\n      profile && args.push(new Date() - start);\n      callback && callback.apply(null, args);\n    });\n  };\n}\n/**\r\n * rand function (bound to index)\r\n *\r\n * @param startsWith {string} - get random word(s) that start with this, or ''\r\n * @param num {number} - number of words to return\r\n * @param callback {function} - callback function, receives words array and startsWith\r\n * @returns Promise\r\n */\n\n\nfunction rand(startsWith, num, callback) {\n  var self = this,\n      nextKey = null,\n      trie = this.fastIndex.trie,\n      key,\n      keys;\n  return new Promise(function (resolve, reject) {\n    //console.log('-- ', startsWith, num, self.fastIndex.indexKeys.length);\n    if (startsWith) {\n      key = startsWith.slice(0, KEY_LENGTH);\n      /**\r\n       * if key is 'a' or 'ab' (<3 chars), search for ALL keys starting with that.\r\n       */\n\n      if (key.length < KEY_LENGTH) {\n        // calc trie if haven't done so yet\n        if (!trie) {\n          trie = new Trie();\n          trie.addStrings(self.fastIndex.indexKeys);\n          self.fastIndex.trie = trie; //console.log(' +++ Trie calc ');\n        }\n\n        try {\n          // trie throws if not found!!!!!\n          keys = trie.keysWithPrefix(startsWith);\n        } catch (e) {\n          keys = [];\n        } // read all keys then select random word.\n        // May be large disk read!\n\n\n        key = keys[0];\n        nextKey = _.last(keys);\n      }\n\n      if (!key || !(key in self.fastIndex.offsets)) {\n        callback && callback([], startsWith);\n        resolve([]);\n      }\n    } else {\n      // no startWith given - random select among keys\n      keys = _.sample(self.fastIndex.indexKeys, num); // if num > 1, run each key independently and collect results\n\n      if (num > 1) {\n        var results = [],\n            ii = 0;\n\n        _(keys).each(function (startsWith) {\n          self.rand(startsWith, 1, function (result) {\n            results.push(result[0]);\n\n            if (++ii == num) {\n              callback && callback(results, '');\n              resolve(results);\n            }\n          });\n        });\n\n        return;\n      }\n\n      key = keys;\n    } // prepare the piper\n\n\n    var args = [key, nextKey, self],\n        task = 'rand:' + key + nextKey,\n        context = [startsWith, num, callback]; // last arg MUST be callback\n    // pay the piper\n\n    self.piper(task, IndexFile.readIndexBetweenKeys, args, context, collector);\n\n    function collector(key, nextKey, index, startsWith, num, callback, buffer) {\n      var lines = buffer.toString().split('\\n'),\n          matches = lines.map(function (line) {\n        return line.substring(0, line.indexOf(' '));\n      }); //console.log(' got lines for key ', key, lines.length);\n      // we got bunch of matches for key - now search within for startsWith\n\n      if (startsWith !== key) {\n        // binary search for startsWith within set of matches\n        var ind = _.sortedIndex(matches, startsWith);\n\n        if (ind >= lines.length || matches[ind].indexOf(startsWith) === -1) {\n          callback && callback([], startsWith);\n          resolve([]);\n          return;\n        }\n\n        var trie = new Trie();\n        trie.addStrings(matches); //console.log('Trie > ', trie.matchesWithPrefix( startsWith ));\n\n        matches = trie.keysWithPrefix(startsWith);\n      }\n\n      var words = _.sample(matches, num);\n\n      callback && callback(words, startsWith);\n      resolve(words);\n    }\n  }); // Promise\n} // relative weight of each POS word count (DB 3.1 numbers)\n\n\nvar POS_factor = {\n  Noun: 26,\n  Verb: 3,\n  Adjective: 5,\n  Adverb: 1,\n  Total: 37\n};\n/**\r\n * rand() - for all Index files\r\n * @returns Promise\r\n */\n\nfunction randAll(opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  } else {\n    opts = _.clone(opts || {});\n  }\n\n  var profile = this.options.profile,\n      start = profile && new Date(),\n      results = [],\n      startsWith = opts && opts.startsWith || '',\n      count = opts && opts.count || 1,\n      args = [null, startsWith],\n      parts = 'Noun Verb Adjective Adverb'.split(' '),\n      self = this;\n  return new Promise(function (resolve, reject) {\n    // select at random a POS to look at\n    var doParts = _.sample(parts, parts.length);\n\n    tryPart();\n\n    function tryPart() {\n      var part = doParts.pop(),\n          rand = 'rand' + part,\n          factor = POS_factor[part],\n          weight = factor / POS_factor.Total; // pick count according to relative weight\n\n      opts.count = Math.ceil(count * weight * 1.1); // guard against dupes\n\n      self[rand](opts, partCallback);\n    }\n\n    function partCallback(result) {\n      if (result) {\n        results = _.uniq(results.concat(result)); // make sure it's unique!\n      }\n\n      if (results.length < count && doParts.length) {\n        return tryPart();\n      } // final random and trim excess\n\n\n      results = _.sample(results, count);\n      done();\n    }\n\n    function done() {\n      profile && args.push(new Date() - start);\n      args[0] = results;\n      callback && callback.apply(null, args);\n      resolve(results);\n    }\n  }); // Promise\n}\n/**\r\n * bind rand() to index\r\n *\r\n * @param index {object} - the IndexFile instance\r\n * @returns {function} - bound rand function for index\r\n */\n\n\nfunction randomify(index) {\n  if (!index.fastIndex) throw 'rand requires fastIndex';\n  return _.bind(rand, index);\n}\n\nmodule.exports = {\n  init: function init(wordposProto) {\n    wordposProto.nounIndex.rand = randomify(wordposProto.nounIndex);\n    wordposProto.verbIndex.rand = randomify(wordposProto.verbIndex);\n    wordposProto.adjIndex.rand = randomify(wordposProto.adjIndex);\n    wordposProto.advIndex.rand = randomify(wordposProto.advIndex);\n    /**\r\n     * define rand()\r\n     */\n\n    wordposProto.rand = randAll;\n    /**\r\n     * define randX()\r\n     */\n\n    wordposProto.randAdjective = makeRandX('a');\n    wordposProto.randAdverb = makeRandX('r');\n    wordposProto.randNoun = makeRandX('n');\n    wordposProto.randVerb = makeRandX('v');\n  }\n};","map":{"version":3,"sources":["/Users/tenzy/Documents/work/vata-hackathon-fe/atva/node_modules/wordpos/src/rand.js"],"names":["_","require","util","Trie","IndexFile","KEY_LENGTH","makeRandX","pos","opts","callback","_noprofile","profile","options","start","Date","args","index","getFilesFor","startsWith","count","rand","record","push","apply","num","self","nextKey","trie","fastIndex","key","keys","Promise","resolve","reject","slice","length","addStrings","indexKeys","keysWithPrefix","e","last","offsets","sample","results","ii","each","result","task","context","piper","readIndexBetweenKeys","collector","buffer","lines","toString","split","matches","map","line","substring","indexOf","ind","sortedIndex","words","POS_factor","Noun","Verb","Adjective","Adverb","Total","randAll","clone","parts","doParts","tryPart","part","pop","factor","weight","Math","ceil","partCallback","uniq","concat","done","randomify","bind","module","exports","init","wordposProto","nounIndex","verbIndex","adjIndex","advIndex","randAdjective","randAdverb","randNoun","randVerb"],"mappings":"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","sourcesContent":["/*!\r\n * rand.js\r\n *\r\n * \t\tdefine rand() and randX() functions on wordpos\r\n *\r\n * Copyright (c) 2012-2016 mooster@42at.com\r\n * https://github.com/moos/wordpos\r\n *\r\n * Released under MIT license\r\n */\r\n\r\nvar _ = require('underscore')._,\r\n  util = require('util'),\r\n  Trie = require('../lib/natural/trie/trie'),\r\n  IndexFile = require('./indexFile'),\r\n  KEY_LENGTH = 3;\r\n\r\n\r\n/**\r\n * factory function for randX()\r\n *\r\n * @param pos {string} - a,r,n,v\r\n * @returns {Function} - rand function bound to an index file\r\n */\r\nfunction makeRandX(pos){\r\n  return function(opts, callback, _noprofile) {\r\n    // disable profiling when isX() used internally\r\n    var profile = this.options.profile && !_noprofile,\r\n      start = profile && new Date(),\r\n      args = [],\r\n      index = this.getFilesFor(pos).index,\r\n      startsWith = opts && opts.startsWith || '',\r\n      count = opts && opts.count || 1;\r\n\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n    }\r\n\r\n    return index.rand(startsWith, count, function (record) {\r\n      args.push(record, startsWith);\r\n      profile && args.push(new Date() - start);\r\n      callback && callback.apply(null, args);\r\n    });\r\n  };\r\n}\r\n\r\n/**\r\n * rand function (bound to index)\r\n *\r\n * @param startsWith {string} - get random word(s) that start with this, or ''\r\n * @param num {number} - number of words to return\r\n * @param callback {function} - callback function, receives words array and startsWith\r\n * @returns Promise\r\n */\r\nfunction rand(startsWith, num, callback){\r\n  var self = this,\r\n    nextKey = null,\r\n    trie = this.fastIndex.trie,\r\n    key, keys;\r\n\r\n  return new Promise(function(resolve, reject) {\r\n\r\n    //console.log('-- ', startsWith, num, self.fastIndex.indexKeys.length);\r\n    if (startsWith) {\r\n      key = startsWith.slice(0, KEY_LENGTH);\r\n\r\n      /**\r\n       * if key is 'a' or 'ab' (<3 chars), search for ALL keys starting with that.\r\n       */\r\n      if (key.length < KEY_LENGTH) {\r\n\r\n        // calc trie if haven't done so yet\r\n        if (!trie) {\r\n          trie = new Trie();\r\n          trie.addStrings(self.fastIndex.indexKeys);\r\n          self.fastIndex.trie = trie;\r\n          //console.log(' +++ Trie calc ');\r\n        }\r\n\r\n        try {\r\n          // trie throws if not found!!!!!\r\n          keys = trie.keysWithPrefix(startsWith);\r\n        } catch (e) {\r\n          keys = [];\r\n        }\r\n\r\n        // read all keys then select random word.\r\n        // May be large disk read!\r\n        key = keys[0];\r\n        nextKey = _.last(keys);\r\n      }\r\n\r\n      if (!key || !(key in self.fastIndex.offsets))  {\r\n        callback && callback([], startsWith);\r\n        resolve([]);\r\n      }\r\n\r\n    } else {\r\n      // no startWith given - random select among keys\r\n      keys = _.sample(self.fastIndex.indexKeys, num);\r\n\r\n      // if num > 1, run each key independently and collect results\r\n      if (num > 1) {\r\n        var results = [], ii = 0;\r\n        _(keys).each(function (startsWith) {\r\n          self.rand(startsWith, 1, function (result) {\r\n            results.push(result[0]);\r\n            if (++ii == num) {\r\n              callback && callback(results, '');\r\n              resolve(results);\r\n            }\r\n          });\r\n        });\r\n        return;\r\n      }\r\n      key = keys;\r\n    }\r\n\r\n    // prepare the piper\r\n    var args = [key, nextKey, self],\r\n      task = 'rand:' + key + nextKey,\r\n      context = [startsWith, num, callback]; // last arg MUST be callback\r\n\r\n    // pay the piper\r\n    self.piper(task, IndexFile.readIndexBetweenKeys, args, context, collector);\r\n\r\n    function collector(key, nextKey, index, startsWith, num, callback, buffer) {\r\n      var lines = buffer.toString().split('\\n'),\r\n        matches = lines.map(function (line) {\r\n          return line.substring(0, line.indexOf(' '));\r\n        });\r\n      //console.log(' got lines for key ', key, lines.length);\r\n\r\n      // we got bunch of matches for key - now search within for startsWith\r\n      if (startsWith !== key) {\r\n        // binary search for startsWith within set of matches\r\n        var ind = _.sortedIndex(matches, startsWith);\r\n        if (ind >= lines.length || matches[ind].indexOf(startsWith) === -1) {\r\n          callback && callback([], startsWith);\r\n          resolve([]);\r\n          return;\r\n        }\r\n\r\n        var trie = new Trie();\r\n        trie.addStrings(matches);\r\n        //console.log('Trie > ', trie.matchesWithPrefix( startsWith ));\r\n        matches = trie.keysWithPrefix(startsWith);\r\n      }\r\n\r\n      var words = _.sample(matches, num);\r\n      callback && callback(words, startsWith);\r\n      resolve(words);\r\n    }\r\n\r\n  }); // Promise\r\n}\r\n\r\n// relative weight of each POS word count (DB 3.1 numbers)\r\nvar POS_factor = {\r\n  Noun: 26,\r\n  Verb: 3,\r\n  Adjective: 5,\r\n  Adverb: 1,\r\n  Total: 37\r\n};\r\n\r\n/**\r\n * rand() - for all Index files\r\n * @returns Promise\r\n */\r\nfunction randAll(opts, callback) {\r\n\r\n  if (typeof opts === 'function') {\r\n    callback = opts;\r\n    opts = {};\r\n  } else {\r\n    opts = _.clone(opts || {});\r\n  }\r\n\r\n  var\r\n    profile = this.options.profile,\r\n    start = profile && new Date(),\r\n    results = [],\r\n    startsWith = opts && opts.startsWith || '',\r\n    count = opts && opts.count || 1,\r\n    args = [null, startsWith],\r\n    parts = 'Noun Verb Adjective Adverb'.split(' '),\r\n    self = this;\r\n\r\n\r\n\r\n  return new Promise(function(resolve, reject) {\r\n    // select at random a POS to look at\r\n    var doParts = _.sample(parts, parts.length);\r\n    tryPart();\r\n\r\n    function tryPart() {\r\n      var part = doParts.pop(),\r\n        rand = 'rand' + part,\r\n        factor = POS_factor[part],\r\n        weight = factor / POS_factor.Total;\r\n\r\n      // pick count according to relative weight\r\n      opts.count = Math.ceil(count * weight * 1.1); // guard against dupes\r\n      self[rand](opts, partCallback);\r\n    }\r\n\r\n    function partCallback(result) {\r\n      if (result) {\r\n        results = _.uniq(results.concat(result));  // make sure it's unique!\r\n      }\r\n\r\n      if (results.length < count && doParts.length) {\r\n        return tryPart();\r\n      }\r\n\r\n      // final random and trim excess\r\n      results = _.sample(results, count);\r\n      done();\r\n    }\r\n\r\n    function done() {\r\n      profile && (args.push(new Date() - start));\r\n      args[0] = results;\r\n      callback && callback.apply(null, args);\r\n      resolve(results);\r\n    }\r\n\r\n  }); // Promise\r\n}\r\n\r\n/**\r\n * bind rand() to index\r\n *\r\n * @param index {object} - the IndexFile instance\r\n * @returns {function} - bound rand function for index\r\n */\r\nfunction randomify(index){\r\n  if (!index.fastIndex) throw 'rand requires fastIndex';\r\n  return _.bind(rand, index);\r\n}\r\n\r\n\r\n\r\nmodule.exports = {\r\n\r\n  init: function(wordposProto) {\r\n    wordposProto.nounIndex.rand = randomify(wordposProto.nounIndex);\r\n    wordposProto.verbIndex.rand = randomify(wordposProto.verbIndex);\r\n    wordposProto.adjIndex.rand = randomify(wordposProto.adjIndex);\r\n    wordposProto.advIndex.rand = randomify(wordposProto.advIndex);\r\n\r\n    /**\r\n     * define rand()\r\n     */\r\n    wordposProto.rand = randAll;\r\n\r\n    /**\r\n     * define randX()\r\n     */\r\n    wordposProto.randAdjective = makeRandX('a');\r\n    wordposProto.randAdverb = makeRandX('r');\r\n    wordposProto.randNoun = makeRandX('n');\r\n    wordposProto.randVerb = makeRandX('v');\r\n  }\r\n};\r\n\r\n"]},"metadata":{},"sourceType":"script"}