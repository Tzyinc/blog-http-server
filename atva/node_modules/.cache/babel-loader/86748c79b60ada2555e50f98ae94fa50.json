{"ast":null,"code":"/*\n    Classifier class that provides functionality for training and\n    classification\n    Copyright (C) 2017 Hugo W.L. ter Doest\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\nvar fs = require('fs');\n\nvar Context = require('./Context');\n\nvar Element = require('./Element');\n\nvar Sample = require('./Sample');\n\nvar Scaler = require('./GISScaler');\n\nvar FeatureSet = require('./FeatureSet');\n\nfunction Classifier(features, sample) {\n  if (features) {\n    this.features = features;\n  } else {\n    this.features = new featureSet();\n  }\n\n  this.features = features;\n\n  if (sample) {\n    this.sample = sample;\n  } else {\n    this.sample = new Sample();\n  }\n} // Loads a classifier from file.\n// Caveat: feature functions are generated from the sample elements. You need\n// to create your own specialisation of the Element class that can generate\n// your own specific feature functions\n\n\nClassifier.prototype.load = function (filename, elementClass, callback) {\n  fs.readFile(filename, 'utf8', function (err, data) {\n    if (!err) {\n      classifierData = JSON.parse(data);\n      var sample = new Sample();\n      classifierData.sample.elements.forEach(function (elementData) {\n        var elt = new elementClass(elementData.a, new Context(elementData.b.data));\n        sample.addElement(elt);\n      });\n      var featureSet = new FeatureSet();\n      sample.generateFeatures(featureSet);\n      var classifier = new Classifier(featureSet, sample);\n      callback(err, classifier);\n    } else {\n      if (callback) {\n        callback(err);\n      }\n    }\n  });\n};\n\nClassifier.prototype.save = function (filename, callback) {\n  var data = JSON.stringify(this, null, 2);\n  var classifier = this;\n  fs.writeFile(filename, data, 'utf8', function (err) {\n    if (callback) {\n      callback(err, err ? null : classifier);\n    }\n  });\n};\n\nClassifier.prototype.addElement = function (x) {\n  this.sample.addElement(x);\n};\n\nClassifier.prototype.addDocument = function (context, classification, elementClass) {\n  Classifier.prototype.addElement(new elementClass(classification, context));\n};\n\nClassifier.prototype.train = function (maxIterations, minImprovement, approxExpectation) {\n  this.scaler = new Scaler(this.features, this.sample);\n  this.p = this.scaler.run(maxIterations, minImprovement, approxExpectation);\n};\n\nClassifier.prototype.getClassifications = function (b) {\n  var scores = [];\n  var that = this;\n  this.sample.getClasses().forEach(function (a) {\n    var x = new Element(a, b);\n    scores.push({\n      \"label\": a,\n      \"value\": that.p.calculateAPriori(x)\n    });\n  });\n  return scores;\n};\n\nClassifier.prototype.classify = function (b) {\n  var scores = this.getClassifications(b); // Sort the scores in an array\n\n  scores.sort(function (a, b) {\n    return b.value - a.value;\n  }); // Check if the classifier discriminates\n\n  var min = scores[scores.length - 1].value;\n  var max = scores[0].value;\n\n  if (min === max) {\n    return \"\";\n  } else {\n    // Return the highest scoring classes\n    return scores[0].label;\n  }\n};\n\nmodule.exports = Classifier;","map":{"version":3,"sources":["/Users/tenzy/Documents/work/vata-hackathon-fe/atva/node_modules/natural/lib/natural/classifiers/maxent/Classifier.js"],"names":["fs","require","Context","Element","Sample","Scaler","FeatureSet","Classifier","features","sample","featureSet","prototype","load","filename","elementClass","callback","readFile","err","data","classifierData","JSON","parse","elements","forEach","elementData","elt","a","b","addElement","generateFeatures","classifier","save","stringify","writeFile","x","addDocument","context","classification","train","maxIterations","minImprovement","approxExpectation","scaler","p","run","getClassifications","scores","that","getClasses","push","calculateAPriori","classify","sort","value","min","length","max","label","module","exports"],"mappings":"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","sourcesContent":["/*\n    Classifier class that provides functionality for training and\n    classification\n    Copyright (C) 2017 Hugo W.L. ter Doest\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nvar fs = require('fs');\n\nvar Context = require('./Context');\nvar Element = require('./Element');\nvar Sample = require('./Sample');\nvar Scaler = require('./GISScaler');\nvar FeatureSet = require('./FeatureSet');\n\nfunction Classifier(features, sample) {\n  if (features) {\n    this.features = features;\n  }\n  else {\n    this.features = new featureSet();\n  }\n  this.features = features;\n  if (sample) {\n    this.sample = sample;\n  }\n  else {\n    this.sample = new Sample();\n  }\n}\n\n// Loads a classifier from file.\n// Caveat: feature functions are generated from the sample elements. You need\n// to create your own specialisation of the Element class that can generate\n// your own specific feature functions\nClassifier.prototype.load = function(filename, elementClass, callback) {\n  fs.readFile(filename, 'utf8', function(err, data) {\n\n    if(!err) {\n        classifierData = JSON.parse(data);\n        var sample = new Sample();\n        classifierData.sample.elements.forEach(function(elementData) {\n          var elt = new elementClass(elementData.a, new Context(elementData.b.data));\n          sample.addElement(elt);\n        });\n        var featureSet = new FeatureSet();\n        sample.generateFeatures(featureSet);\n        var classifier = new Classifier(featureSet, sample);\n        callback(err, classifier);\n    }\n    else {\n      if(callback) {\n        callback(err);\n      }\n    }\n  });\n};\n\nClassifier.prototype.save = function(filename, callback) {\n  var data = JSON.stringify(this, null, 2);\n  var classifier = this;\n  fs.writeFile(filename, data, 'utf8', function(err) {\n      if(callback) {\n          callback(err, err ? null : classifier);\n      }\n  });\n};\n\nClassifier.prototype.addElement = function(x) {\n  this.sample.addElement(x);\n};\n\nClassifier.prototype.addDocument = function(context, classification, elementClass) {\n  Classifier.prototype.addElement(new elementClass(classification, context));\n};\n\nClassifier.prototype.train = function(maxIterations, minImprovement, approxExpectation) {\n  this.scaler = new Scaler(this.features, this.sample);\n  this.p = this.scaler.run(maxIterations, minImprovement, approxExpectation);\n};\n\nClassifier.prototype.getClassifications = function(b) {\n  var scores = [];\n  var that = this;\n  this.sample.getClasses().forEach(function(a) {\n    var x = new Element(a, b);\n    scores.push({\n      \"label\": a,\n      \"value\": that.p.calculateAPriori(x)\n    });\n  });\n  return scores;\n};\n\nClassifier.prototype.classify = function(b) {\n  var scores = this.getClassifications(b);\n  // Sort the scores in an array\n  scores.sort(function(a, b) {\n    return b.value - a.value;\n  });\n  // Check if the classifier discriminates\n  var min = scores[scores.length - 1].value;\n  var max = scores[0].value;\n  if (min === max) {\n      return \"\";\n  }\n  else {\n    // Return the highest scoring classes\n    return scores[0].label;\n  }\n};\n\nmodule.exports = Classifier;\n"]},"metadata":{},"sourceType":"script"}