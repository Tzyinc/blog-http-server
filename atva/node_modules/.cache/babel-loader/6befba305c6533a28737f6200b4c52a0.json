{"ast":null,"code":"/*\n  Lexicon class\n  Copyright (C) 2016 Hugo W.L. ter Doest\n\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\nvar fs = require('fs'); // Parses a lexicon in JSON or text format\n\n\nfunction Lexicon(filename, defaultCategory, defaultCategoryCapitalised) {\n  this.lexicon = {}; //Object.create(null);\n\n  if (filename) {\n    this.defaultCategory = defaultCategory; // Read lexicon\n\n    try {\n      var data = fs.readFileSync(filename, 'utf8');\n\n      if (data[0] === \"{\") {\n        // Lexicon is in JSON format\n        this.lexicon = JSON.parse(data);\n      } else {\n        // Lexicon is plain text\n        this.parseLexicon(data);\n      } //console.log('Brill_POS_Tagger.read_lexicon: number of lexicon entries read: ' + Object.keys(this.lexicon).length);\n\n    } catch (error) {\n      console.error(error);\n    }\n\n    if (defaultCategory) {\n      this.defaultCategory = defaultCategory;\n\n      if (defaultCategoryCapitalised) {\n        this.defaultCategoryCapitalised = defaultCategoryCapitalised;\n      }\n    }\n  }\n} // Parses a lexicon in text format: word cat1 cat2 ... catn\n\n\nLexicon.prototype.parseLexicon = function (data) {\n  // Split into an array of non-empty lines\n  var arrayOfLines = data.match(/[^\\r\\n]+/g);\n  this.lexicon = {}; //Object.create(null);\n\n  var that = this;\n  arrayOfLines.forEach(function (line) {\n    // Split line by whitespace\n    var elements = line.trim().split(/\\s+/);\n\n    if (elements.length > 0) {\n      that.lexicon[elements[0]] = elements.slice(1);\n    }\n  });\n};\n\nLexicon.prototype.tagWordWithDefaults = function (word) {\n  if (/[A-Z]/.test(word[0]) && this.defaultCategoryCapitalised) {\n    // Capitalised\n    return this.defaultCategoryCapitalised;\n  } else {\n    // If not found assign default_category\n    return this.defaultCategory;\n  }\n}; // Returns a list of categories for word\n\n\nLexicon.prototype.tagWord = function (word) {\n  var categories = this.lexicon[word]; //console.log(categories);\n\n  if (!categories || typeof categories == \"function\") {\n    categories = this.lexicon[word.toLowerCase()];\n  }\n\n  if (!categories || typeof categories == \"function\") {\n    categories = [this.tagWordWithDefaults(word)];\n  }\n\n  return categories;\n}; // Adds a word to the lexicon. NB simply replaces the entry\n\n\nLexicon.prototype.addWord = function (word, categories) {\n  this.lexicon[word] = categories;\n};\n\nLexicon.prototype.prettyPrint = function () {\n  var result = \"\";\n  var that = this;\n  Object.keys(this.lexicon).forEach(function (token) {\n    result += token + \"\\t\";\n    that.lexicon[token].forEach(function (cat) {\n      result += cat + \"\\t\";\n    });\n    result += \"\\n\";\n  });\n  return result;\n};\n\nLexicon.prototype.nrEntries = function () {\n  return Object.keys(this.lexicon).length;\n};\n\nLexicon.prototype.size = function () {\n  return this.nrEntries();\n};\n\nLexicon.prototype.setDefaultCategories = function (category, categoryCapitalised) {\n  this.defaultCategory = category;\n\n  if (categoryCapitalised) {\n    this.defaultCategoryCapitalised = categoryCapitalised;\n  }\n};\n\nmodule.exports = Lexicon;","map":{"version":3,"sources":["/Users/tenzy/Documents/work/vata-hackathon-fe/atva/node_modules/natural/lib/natural/brill_pos_tagger/lib/Lexicon.js"],"names":["fs","require","Lexicon","filename","defaultCategory","defaultCategoryCapitalised","lexicon","data","readFileSync","JSON","parse","parseLexicon","error","console","prototype","arrayOfLines","match","that","forEach","line","elements","trim","split","length","slice","tagWordWithDefaults","word","test","tagWord","categories","toLowerCase","addWord","prettyPrint","result","Object","keys","token","cat","nrEntries","size","setDefaultCategories","category","categoryCapitalised","module","exports"],"mappings":"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","sourcesContent":["/*\n  Lexicon class\n  Copyright (C) 2016 Hugo W.L. ter Doest\n\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nvar fs = require('fs');\n\n// Parses a lexicon in JSON or text format\nfunction Lexicon(filename, defaultCategory, defaultCategoryCapitalised) {\n  this.lexicon = {}; //Object.create(null);\n\n  if (filename) {\n    this.defaultCategory = defaultCategory;\n    // Read lexicon\n    try {\n      var data = fs.readFileSync(filename, 'utf8');\n      if (data[0] === \"{\") {\n        // Lexicon is in JSON format\n        this.lexicon = JSON.parse(data);\n      }\n      else {\n        // Lexicon is plain text\n        this.parseLexicon(data);\n      }\n      //console.log('Brill_POS_Tagger.read_lexicon: number of lexicon entries read: ' + Object.keys(this.lexicon).length);\n    }\n    catch (error) {\n      console.error(error);\n    }\n    if (defaultCategory) {\n      this.defaultCategory = defaultCategory;\n      if (defaultCategoryCapitalised) {\n        this.defaultCategoryCapitalised = defaultCategoryCapitalised;\n      }\n    }\n  }\n}\n\n// Parses a lexicon in text format: word cat1 cat2 ... catn\nLexicon.prototype.parseLexicon = function(data) {\n  // Split into an array of non-empty lines\n  var arrayOfLines = data.match(/[^\\r\\n]+/g);\n  this.lexicon = {}; //Object.create(null);\n  var that = this;\n  arrayOfLines.forEach(function(line) {\n    // Split line by whitespace\n    var elements = line.trim().split(/\\s+/);\n    if (elements.length > 0) {\n      that.lexicon[elements[0]] = elements.slice(1);\n    }\n  });\n};\n\nLexicon.prototype.tagWordWithDefaults = function(word) {\n  if (/[A-Z]/.test(word[0]) && this.defaultCategoryCapitalised) {\n    // Capitalised\n    return this.defaultCategoryCapitalised;\n  }\n  else {\n    // If not found assign default_category\n    return this.defaultCategory;\n  }\n};\n\n// Returns a list of categories for word\nLexicon.prototype.tagWord = function(word) {\n  var categories = this.lexicon[word];\n  //console.log(categories);\n  if (!categories || (typeof categories == \"function\")) {\n    categories = this.lexicon[word.toLowerCase()];\n  }\n  if (!categories || (typeof categories == \"function\")) {\n    categories = [this.tagWordWithDefaults(word)];\n  }\n  return(categories);\n};\n\n// Adds a word to the lexicon. NB simply replaces the entry\nLexicon.prototype.addWord = function(word, categories) {\n  this.lexicon[word] = categories;\n};\n\nLexicon.prototype.prettyPrint = function() {\n  var result = \"\";\n  var that = this;\n  Object.keys(this.lexicon).forEach(function(token) {\n    result += token + \"\\t\";\n    that.lexicon[token].forEach(function(cat) {\n      result += cat + \"\\t\";\n    });\n    result += \"\\n\";\n  });\n  return result;\n};\n\nLexicon.prototype.nrEntries = function() {\n  return Object.keys(this.lexicon).length;\n};\n\nLexicon.prototype.size = function() {\n  return this.nrEntries();\n};\n\nLexicon.prototype.setDefaultCategories = function(category, categoryCapitalised) {\n  this.defaultCategory = category;\n  if (categoryCapitalised) {\n    this.defaultCategoryCapitalised = categoryCapitalised;\n  }\n};\n\nmodule.exports = Lexicon;\n"]},"metadata":{},"sourceType":"script"}