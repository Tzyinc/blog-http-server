{"ast":null,"code":"/*\n  Transformation rules for the Brill tagger\n  Copyright (C) 2017 Hugo W.L. ter Doest\n\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n//var log4js = require('log4js');\n//var logger = log4js.getLogger();\nvar Predicate = require(\"./Predicate\");\n\nvar Sentence = require('./Sentence'); //logger.setLevel('INFO');\n\n\nvar category_wild_card = \"*\";\n\nfunction TransformationRule(c1, c2, predicate, parameter1, parameter2) {\n  this.literal = [c1, c2, predicate, parameter1, parameter2];\n  this.predicate = new Predicate(predicate, parameter1, parameter2);\n  this.old_category = c1;\n  this.new_category = c2; // These members are for the learning algorithm\n\n  this.neutral = 0;\n  this.negative = 0;\n  this.positive = 0;\n  this.hasBeenSelectedAsHighRuleBefore = false; //logger.debug('TransformationRule constructor: ' + this.literal);\n}\n\nTransformationRule.prototype.key = function () {\n  return this.literal.toString();\n};\n\nTransformationRule.prototype.apply = function (sentence, position) {\n  if (sentence.taggedWords[position].tag === this.old_category || this.old_category === category_wild_card) {\n    if (this.predicate.evaluate(sentence, position)) {\n      sentence.taggedWords[position].tag = this.new_category; //logger.debug('TransformationRule.apply: changed category ' +\n      //this.old_category + ' to ' + this.new_category +\n      //' at position ' + position);\n    }\n  }\n}; //\n// Methods for processing sentences from a corpus that consist of an array of tokens\n//\n// Returns true if the rule applies at site. As a side effect it assigns the new\n// category to newTag\n\n\nTransformationRule.prototype.isApplicableAt = function (sentence, taggedSentence, i) {\n  //logger.debug(\"TransformationRule.prototype.isApplicableAt: \" + taggedSentence);\n  var applies = taggedSentence.taggedWords[i].tag === this.old_category && this.predicate.evaluate(taggedSentence, i); //logger.debug(\"TransformationRule.prototype.isApplicableAt: \" + applies);\n  // Set newTag to let the trainer know what the new tag would become\n\n  if (applies) {\n    sentence.taggedWords[i].newTag = this.new_category;\n  }\n\n  return applies;\n};\n\nTransformationRule.prototype.prettyPrint = function () {\n  var result = \"\"; // Old category and new category\n\n  result += this.old_category + \" \" + this.new_category; // Predicate name\n\n  result += \" \" + this.predicate.name; // Parameter 1 and 2\n\n  if (this.predicate.parameter1) {\n    result += \" \" + this.predicate.parameter1;\n\n    if (this.predicate.parameter2) {\n      result += \" \" + this.predicate.parameter2;\n    }\n  }\n\n  return result;\n}; // Applies the rule the given location (if it applies)\n\n\nTransformationRule.prototype.applyAt = function (sentence, i) {\n  var taggedSentence = sentence.clone(); //logger.debug(\"TransformationRule.prototype.applyAt: input sentence length: \" + sentence.length);\n  //logger.debug(\"TransformationRule.prototype.applyAt: tagged sentence length: \" + taggedSentence.length);\n\n  this.apply(sentence, i); // Assign the new tag to the corpus site\n\n  sentence.taggedWords[i].testTag = taggedSentence.taggedWords[i].tag;\n}; // Calculate the net score of this rule\n\n\nTransformationRule.prototype.score = function () {\n  return this.positive - this.negative;\n};\n\nmodule.exports = TransformationRule;","map":{"version":3,"sources":["/Users/tenzy/Documents/work/vata-hackathon-fe/atva/node_modules/natural/lib/natural/brill_pos_tagger/lib/TransformationRule.js"],"names":["Predicate","require","Sentence","category_wild_card","TransformationRule","c1","c2","predicate","parameter1","parameter2","literal","old_category","new_category","neutral","negative","positive","hasBeenSelectedAsHighRuleBefore","prototype","key","toString","apply","sentence","position","taggedWords","tag","evaluate","isApplicableAt","taggedSentence","i","applies","newTag","prettyPrint","result","name","applyAt","clone","testTag","score","module","exports"],"mappings":"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","sourcesContent":["/*\n  Transformation rules for the Brill tagger\n  Copyright (C) 2017 Hugo W.L. ter Doest\n\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n//var log4js = require('log4js');\n//var logger = log4js.getLogger();\n\nvar Predicate = require(\"./Predicate\");\nvar Sentence = require('./Sentence');\n\n//logger.setLevel('INFO');\n\nvar category_wild_card = \"*\";\n\nfunction TransformationRule(c1, c2, predicate, parameter1, parameter2) {\n  this.literal = [c1, c2, predicate, parameter1, parameter2];\n  this.predicate = new Predicate(predicate, parameter1, parameter2);\n  this.old_category = c1;\n  this.new_category = c2;\n  // These members are for the learning algorithm\n  this.neutral = 0;\n  this.negative = 0;\n  this.positive = 0;\n  this.hasBeenSelectedAsHighRuleBefore = false;\n  //logger.debug('TransformationRule constructor: ' + this.literal);\n}\n\nTransformationRule.prototype.key = function() {\n  return(this.literal.toString());\n};\n\nTransformationRule.prototype.apply = function(sentence, position) {\n  if ((sentence.taggedWords[position].tag === this.old_category) ||\n      (this.old_category === category_wild_card)) {\n    if (this.predicate.evaluate(sentence, position)) {\n      sentence.taggedWords[position].tag = this.new_category;\n      //logger.debug('TransformationRule.apply: changed category ' +\n        //this.old_category + ' to ' + this.new_category +\n        //' at position ' + position);\n    }\n  }\n};\n\n//\n// Methods for processing sentences from a corpus that consist of an array of tokens\n//\n\n// Returns true if the rule applies at site. As a side effect it assigns the new\n// category to newTag\nTransformationRule.prototype.isApplicableAt = function(sentence, taggedSentence, i) {\n  //logger.debug(\"TransformationRule.prototype.isApplicableAt: \" + taggedSentence);\n  var applies = (taggedSentence.taggedWords[i].tag === this.old_category) &&\n    this.predicate.evaluate(taggedSentence, i);\n  //logger.debug(\"TransformationRule.prototype.isApplicableAt: \" + applies);\n\n  // Set newTag to let the trainer know what the new tag would become\n  if (applies) {\n    sentence.taggedWords[i].newTag = this.new_category;\n  }\n  return(applies);\n};\n\nTransformationRule.prototype.prettyPrint = function() {\n  var result = \"\";\n  // Old category and new category\n  result += this.old_category + \" \" + this.new_category;\n  // Predicate name\n  result += \" \" + this.predicate.name;\n  // Parameter 1 and 2\n  if (this.predicate.parameter1) {\n    result += \" \" + this.predicate.parameter1;\n    if (this.predicate.parameter2) {\n      result += \" \" + this.predicate.parameter2;\n    }\n  }\n  return result;\n};\n\n\n// Applies the rule the given location (if it applies)\nTransformationRule.prototype.applyAt = function(sentence, i) {\n  var taggedSentence = sentence.clone();\n\n  //logger.debug(\"TransformationRule.prototype.applyAt: input sentence length: \" + sentence.length);\n  //logger.debug(\"TransformationRule.prototype.applyAt: tagged sentence length: \" + taggedSentence.length);\n\n  this.apply(sentence, i);\n  // Assign the new tag to the corpus site\n  sentence.taggedWords[i].testTag = taggedSentence.taggedWords[i].tag;\n};\n\n// Calculate the net score of this rule\nTransformationRule.prototype.score = function() {\n  return (this.positive - this.negative);\n};\n\nmodule.exports = TransformationRule;\n"]},"metadata":{},"sourceType":"script"}