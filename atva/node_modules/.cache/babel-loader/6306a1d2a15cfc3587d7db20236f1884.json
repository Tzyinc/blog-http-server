{"ast":null,"code":"/*\n  Brill POS Trainer class\n  Copyright (C) 2017 Hugo W.L. ter Doest\n\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n// Algorithm is based on:\n// Exploring the Statistical Derivation of Transformational Rule Sequences\n// for Part-of-Speech Tagging, Lance A. Ramshaw and Mitchell P. Marcus\n// http://acl-arc.comp.nus.edu.sg/archives/acl-arc-090501d4/data/pdf/anthology-PDF/W/W94/W94-0111.pdf\n//var log4js = require('log4js');\n//var logger = log4js.getLogger('Brill_POS_Trainer');\n//logger.setLevel('OFF');\nvar TransformationRule = require(\"./TransformationRule\");\n\nvar RuleSet = require(\"./RuleSet\");\n\nvar Sentence = require('./Sentence'); // Training continues as long as there are rules with a positive score\n// that have not been selected before\n\n\nvar minScore = 0; // After training rules with a score below scoreThreshold are pruned\n\nfunction Brill_POS_Trainer(ruleScoreThreshold) {\n  if (ruleScoreThreshold) {\n    this.ruleScoreThreshold = ruleScoreThreshold;\n  } else {\n    this.ruleScoreThreshold = 1;\n  }\n} // Return the highest scoring rule from the rule set\n\n\nBrill_POS_Trainer.prototype.selectHighRule = function () {\n  var highestRule = null; // Walk through the map and find the rule with highest score\n\n  this.positiveRules.getRules().forEach(function (rule) {\n    if (highestRule === null) {\n      if (!rule.hasBeenSelectedAsHighRuleBefore) {\n        highestRule = rule;\n      }\n    } else {\n      if (rule.score() > highestRule.score() && !rule.hasBeenSelectedAsHighRuleBefore) {\n        highestRule = rule;\n      }\n    }\n  });\n\n  if (highestRule !== null) {\n    highestRule.hasBeenSelectedAsHighRuleBefore = true;\n  } // Return the rule with the highest score\n\n\n  return highestRule;\n};\n\nBrill_POS_Trainer.prototype.mapRuleToSite = function (rule, i, j) {\n  if (!this.mapRuleToSites[rule.key()]) {\n    this.mapRuleToSites[rule.key()] = {};\n  }\n\n  if (!this.mapRuleToSites[rule.key()][i]) {\n    this.mapRuleToSites[rule.key()][i] = {};\n  }\n\n  this.mapRuleToSites[rule.key()][i][j] = true;\n};\n\nBrill_POS_Trainer.prototype.mapSiteToRule = function (i, j, rule) {\n  if (!this.mapSiteToRules[i]) {\n    this.mapSiteToRules[i] = {};\n  }\n\n  if (!this.mapSiteToRules[i][j]) {\n    this.mapSiteToRules[i][j] = {};\n  }\n\n  this.mapSiteToRules[i][j][rule.key()] = rule;\n};\n\nBrill_POS_Trainer.prototype.associateSiteWithRule = function (i, j, rule) {\n  this.mapRuleToSite(rule, i, j);\n  this.mapSiteToRule(i, j, rule);\n};\n\nBrill_POS_Trainer.prototype.siteIsAssociatedWithRule = function (i, j, rule) {\n  if (this.mapSiteToRules[i]) {\n    if (this.mapSiteToRules[i][j]) {\n      if (this.mapSiteToRules[i][j][rule.key()]) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}; // Returns an array of all sites associated with rule\n\n\nBrill_POS_Trainer.prototype.getSites = function (rule) {\n  var that = this;\n  var result = [];\n  Object.keys(this.mapRuleToSites[rule.key()]).forEach(function (i) {\n    Object.keys(that.mapRuleToSites[rule.key()][i]).forEach(function (j) {\n      // Unary plus the convert hash keys i and j to integer\n      result.push([+i, +j]);\n    });\n  }); //logger.debug(\"Brill_POS_Trainer.prototype.getSites: sites \" + JSON.stringify(result));\n\n  return result;\n}; // Returns an array of all rules associated with the site\n\n\nBrill_POS_Trainer.prototype.getRules = function (i, j) {\n  var result = [];\n  var that = this;\n\n  if (this.mapSiteToRules[i]) {\n    if (this.mapSiteToRules[i][j]) {\n      result = Object.keys(this.mapSiteToRules[i][j]).map(function (key) {\n        return that.mapSiteToRules[i][j][key];\n      });\n    }\n  }\n\n  return result;\n};\n\nBrill_POS_Trainer.prototype.disconnectSiteFromRule = function (i, j, rule) {\n  // mapRuleToSites\n  if (this.mapRuleToSites[rule.key()]) {\n    if (this.mapRuleToSites[rule.key()][i]) {\n      if (this.mapRuleToSites[rule.key()][i][j]) {\n        delete this.mapRuleToSites[rule.key()][i][j];\n      }\n    }\n  } // mapSiteToRules\n\n\n  if (this.mapSiteToRules[i]) {\n    if (this.mapSiteToRules[i][j]) {\n      if (this.mapSiteToRules[i][j][rule.key()]) {\n        delete this.mapSiteToRules[i][j][rule.key()];\n      }\n    }\n  }\n}; // Adjusts the score of the rule at position i, j of the corpus\n\n\nBrill_POS_Trainer.prototype.scoreRule = function (rule, i, j) {\n  //logger.debug(\"Brill_POS_Trainer.prototype.scoreRule: entry\");\n  var token = this.corpus.sentences[i].taggedWords[j];\n  var rightTag = token.tag;\n  var oldTag = token.testTag;\n  var newTag = token.newTag;\n\n  if (rightTag !== oldTag) {\n    // Old tag is wrong\n    if (newTag === rightTag) {\n      // New tag is right\n      rule.positive++; // If the score changes, it may be selected again as highest scoring rule\n\n      rule.hasBeenSelectedAsHighRuleBefore = false; //logger.debug(\"Brill_POS_Trainer.prototype.scoreRule: positive: \" + rule.key() + \"\\t score: \" + rule.positive);\n    } else {\n      // New tag is wrong as well --> neutral\n      rule.neutral++; //logger.debug(\"Brill_POS_Trainer.prototype.scoreRule: neutral: \" + rule.key() + \"\\t score: \" + rule.neutral);\n    }\n  } else {\n    // Old tag is right\n    if (newTag === rightTag) {\n      // New tag is right --> neutral\n      rule.neutral++; //logger.debug(\"Brill_POS_Trainer.prototype.scoreRule: neutral: \" + rule.key() + \"\\t score: \" + rule.neutral);\n    } else {\n      // New tag is false\n      rule.negative++; // If the score changes, it may be selected again as highest scoring rule\n\n      rule.hasBeenSelectedAsHighRuleBefore = false; //logger.debug(\"Brill_POS_Trainer.prototype.scoreRule: negative: \" + rule.key() + \"\\t score: \" + rule.negative);\n    }\n  } //logger.debug(\"Brill_POS_Trainer.prototype.scoreRule: exit\");\n\n}; // Generate positive rules for this given site using templates\n\n\nBrill_POS_Trainer.prototype.generatePositiveRules = function (i, j) {\n  var sentence = this.corpus.sentences[i];\n  var token = sentence.taggedWords[j]; // A positive rule should trigger on the currently assigned testTag\n\n  var oldTag = token.testTag; //logger.debug(\"Brill_POS_Trainer.prototype.generatePositiveRules: oldTag \" + oldTag);\n  // It should assign the right tag as given by the corpus\n\n  var newTag = token.tag; //logger.debug(\"Brill_POS_Trainer.prototype.generatePositiveRules: newTag \" + newTag);\n\n  var newRules = new RuleSet(); // Exit if testTag already is the right tag --> will not result in positive rules\n\n  if (oldTag === newTag) {\n    return newRules;\n  }\n\n  this.templates.forEach(function (template) {\n    if (template.windowFitsSite(sentence, j)) {\n      if (template.meta.nrParameters === 1) {\n        template.meta.parameter1Values(sentence, j).forEach(function (value) {\n          newRules.addRule(new TransformationRule(oldTag, newTag, template.predicateName, value));\n        });\n      } else {\n        if (template.meta.nrParameters === 2) {\n          template.meta.parameter1Values(sentence, j).forEach(function (value1) {\n            template.meta.parameter2Values(sentence, j).forEach(function (value2) {\n              newRules.addRule(new TransformationRule(oldTag, newTag, template.predicateName, value1, value2));\n            });\n          });\n        } else {\n          // 0 paramaters\n          newRules.addRule(new TransformationRule(oldTag, newTag, template.predicateName));\n        }\n      }\n    }\n  });\n  return newRules;\n}; // Finds all rules that are applicable at some site\n\n\nBrill_POS_Trainer.prototype.scanForPositiveRules = function () {\n  //logger.debug(\"Brill_POS_Trainer.prototype.scanForPositiveRules: entry\");\n  var that = this;\n  this.corpus.sentences.forEach(function (sentence, i) {\n    sentence.taggedWords.forEach(function (token, j) {\n      //logger.debug(\"Brill_POS_Trainer.prototype.scanForPositiveRules: sentence no \" + i);\n      var newRules = that.generatePositiveRules(i, j);\n      newRules.getRules().forEach(function (rule) {\n        that.positiveRules.addRule(rule); //logger.debug(\"Brill_POS_Trainer.prototype.scanForPositiveRules: nrRules \" + that.positiveRules.nrRules());\n      });\n    });\n  }); //logger.debug(\"Brill_POS_Trainer.prototype.scanForPositiveRules: exit, number of rules: \" + this.positiveRules.nrRules());\n}; // Find all sites where the rules can be applied, register these sites and\n// update the scores\n\n\nBrill_POS_Trainer.prototype.scanForSites = function () {\n  //logger.debug(\"Brill_POS_Trainer.prototype.scanForSites: entry\");\n  var that = this; // Scan the corpus\n\n  this.corpus.sentences.forEach(function (sentence, i) {\n    if (i % 100 === 0) {//logger.info(\"Brill_POS_Trainer.prototype.scanForSites: sentence \" + i);\n    }\n\n    var taggedSentence = new Sentence();\n    sentence.taggedWords.forEach(function (wordObject) {\n      taggedSentence.addTaggedWord(wordObject.token, wordObject.testTag);\n    });\n    sentence.taggedWords.forEach(function (token, j) {\n      that.positiveRules.getRules().forEach(function (rule) {\n        if (rule.isApplicableAt(sentence, taggedSentence, j)) {\n          that.associateSiteWithRule(i, j, rule);\n          that.scoreRule(rule, i, j); //logger.debug(\"Brill_POS_Trainer.prototype.scanForSites: (sentence, token, rule): (\" + i + \", \" + j + \", \" + rule.prettyPrint() + \")\");\n        }\n      });\n    });\n  }); //logger.debug(\"Brill_POS_Trainer.prototype.scanForSites: exit\");\n}; // Returns a list of sites that may have been touched by a changing tag\n\n\nBrill_POS_Trainer.prototype.neighbourhood = function (i, j) {\n  var sentenceLength = this.corpus.sentences[i].length;\n  var list = [];\n\n  if (this.index > 2) {\n    list.push([i, j - 3]);\n  }\n\n  if (this.index > 1) {\n    list.push([i, j - 2]);\n  }\n\n  if (this.index > 0) {\n    list.push([i, j - 1]);\n  }\n\n  if (this.index < sentenceLength - 1) {\n    list.push([i, j + 1]);\n  }\n\n  if (this.index < sentenceLength - 2) {\n    list.push([i, j + 2]);\n  }\n\n  if (this.index > sentenceLength - 3) {\n    list.push([i, j + 3]);\n  }\n\n  return list;\n}; // corpus: an array of token arrays\n// templates: an array of rule templates\n// lexicon: lexicon that provides method tagWord(word)\n\n\nBrill_POS_Trainer.prototype.train = function (corpus, templates, lexicon) {\n  this.corpus = corpus;\n  this.templates = templates;\n  this.positiveRules = new RuleSet();\n  this.mapRuleToSites = {};\n  this.mapSiteToRules = {}; //logger.debug(\"Brill_POS_Trainer.prototype.train: entry\");\n\n  this.corpus.tag(lexicon);\n  this.scanForPositiveRules(); //logger.info(\"Brill_POS_Trainer.prototype.train: initial number of rules: \" + this.positiveRules.nrRules());\n\n  this.scanForSites();\n  var highRule = this.selectHighRule();\n  var iterationNumber = 0;\n  var that = this;\n\n  while (highRule !== null && highRule.score() > minScore) {\n    if (iterationNumber % 5 === 0) {} //logger.info(\"Brill_POS_Trainer.prototype.train: training iteration: \" + iterationNumber);\n    //logger.debug(\"Brill_POS_Trainer.prototype.train: highRule selected: \" + highRule.key());\n    //logger.debug(\"Brill_POS_Trainer.prototype.train: number of rules: \" + this.positiveRules.nrRules());\n    //logger.debug(\"Brill_POS_Trainer.prototype.train: score of highRule: \" + highRule.score());\n    // Apply the high rule to each change site on its site list\n\n\n    this.getSites(highRule).forEach(function (site) {\n      //logger.debug(\"Brill_POS_Trainer.prototype.train: apply highRule to: \" + site);\n      //logger.debug(\"Brill_POS_Trainer.prototype.train: sentence length: \" + that.corpus.sentences[site[0]].length);\n      highRule.applyAt(that.corpus.sentences[site[0]], site[1]);\n    });\n    var unseenRules = new RuleSet();\n    this.getSites(highRule).forEach(function (site) {\n      that.neighbourhood(site[0], site[1]).forEach(function (testSite) {\n        // Generate positive rules for testSite\n        var newRules = that.generatePositiveRules(testSite[0], testSite[1]); // Disconnect test site from its rules\n        // because highrule has been applied\n\n        that.getRules(testSite[0], testSite[1]).forEach(function (rule) {\n          if (!newRules.hasRule(rule)) {\n            that.disconnectSiteFromRule(testSite[0], testSite[1], rule);\n          }\n        }); // Connect new rules not already connected to the test site\n\n        newRules.getRules().forEach(function (rule) {\n          if (!that.siteIsAssociatedWithRule(testSite[0].testSite[1], rule)) {\n            if (that.positiveRules.hasRule(rule)) {\n              that.associateSiteWithRule(testSite[0], testSite[1], rule);\n            } else {\n              unseenRules.addRule(rule);\n            }\n          }\n        }); // Process unseen rules\n\n        if (unseenRules.nrRules() > 0) {\n          unseenRules.getRules().forEach(function (rule) {\n            that.positiveRules.addRule(rule);\n          });\n          that.corpus.sentences.forEach(function (sentence, i) {\n            var taggedSentence = sentence.map(function (token) {\n              return [token.token, token.testTag];\n            });\n            sentence.forEach(function (token, j) {\n              unseenRules.getRules().forEach(function (rule) {\n                if (rule.isApplicableAt(sentence, taggedSentence, j)) {\n                  that.associateSiteWithRule(i, j, rule);\n                  that.scoreRule(rule, i, j);\n                }\n              });\n            });\n          });\n        }\n      });\n    }); // Select next highest scoring rule\n\n    highRule = this.selectHighRule();\n    iterationNumber++;\n  } //logger.info(\"Brill_POS_Trainer.prototype.train: number of iterations: \" + iterationNumber);\n  //logger.info(\"Brill_POS_Trainer.prototype.train: number of rules: \" + this.positiveRules.nrRules());\n  // Remove rules having a non-positive score\n\n\n  this.positiveRules.getRules().forEach(function (rule) {\n    if (rule.score() < that.ruleScoreThreshold) {\n      that.positiveRules.removeRule(rule);\n    }\n  }); //logger.info(\"Brill_POS_Trainer.prototype.train: number of rules after pruning: \" + this.positiveRules.nrRules());\n  //logger.debug(\"Brill_POS_Trainer.prototype.train: exit\");\n\n  return this.positiveRules;\n};\n\nBrill_POS_Trainer.prototype.printRulesWithScores = function () {\n  var that = this;\n  var result = \"\";\n\n  function compareRules(a, b) {\n    if (a.score() > b.score()) {\n      return -1;\n    } else {\n      if (a.score() < b.score()) {\n        return 1;\n      } else {\n        return 0;\n      }\n    }\n  }\n\n  var rules = this.positiveRules.getRules();\n  var sortedRules = rules.sort(compareRules);\n  sortedRules.forEach(function (rule) {\n    //if (rule.score() > 0) {\n    result += rule.score() + '\\t' + rule.positive + '\\t' + rule.negative + '\\t' + rule.neutral + '\\t' + rule.prettyPrint() + \"\\n\"; //}\n  });\n  return result;\n};\n\nmodule.exports = Brill_POS_Trainer;","map":{"version":3,"sources":["/Users/tenzy/Documents/work/vata-hackathon-fe/atva/node_modules/natural/lib/natural/brill_pos_tagger/lib/Brill_POS_Trainer.js"],"names":["TransformationRule","require","RuleSet","Sentence","minScore","Brill_POS_Trainer","ruleScoreThreshold","prototype","selectHighRule","highestRule","positiveRules","getRules","forEach","rule","hasBeenSelectedAsHighRuleBefore","score","mapRuleToSite","i","j","mapRuleToSites","key","mapSiteToRule","mapSiteToRules","associateSiteWithRule","siteIsAssociatedWithRule","getSites","that","result","Object","keys","push","map","disconnectSiteFromRule","scoreRule","token","corpus","sentences","taggedWords","rightTag","tag","oldTag","testTag","newTag","positive","neutral","negative","generatePositiveRules","sentence","newRules","templates","template","windowFitsSite","meta","nrParameters","parameter1Values","value","addRule","predicateName","value1","parameter2Values","value2","scanForPositiveRules","scanForSites","taggedSentence","wordObject","addTaggedWord","isApplicableAt","neighbourhood","sentenceLength","length","list","index","train","lexicon","highRule","iterationNumber","site","applyAt","unseenRules","testSite","hasRule","nrRules","removeRule","printRulesWithScores","compareRules","a","b","rules","sortedRules","sort","prettyPrint","module","exports"],"mappings":"AAAA;;;;;;;;;;;;;;;;;AAkBA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA,IAAIA,kBAAkB,GAAGC,OAAO,CAAC,sBAAD,CAAhC;;AACA,IAAIC,OAAO,GAAGD,OAAO,CAAC,WAAD,CAArB;;AACA,IAAIE,QAAQ,GAAGF,OAAO,CAAC,YAAD,CAAtB,C,CAEA;AACA;;;AACA,IAAIG,QAAQ,GAAG,CAAf,C,CAEA;;AACA,SAASC,iBAAT,CAA2BC,kBAA3B,EAA+C;AAC7C,MAAIA,kBAAJ,EAAwB;AACtB,SAAKA,kBAAL,GAA0BA,kBAA1B;AACD,GAFD,MAGK;AACH,SAAKA,kBAAL,GAA0B,CAA1B;AACD;AACF,C,CAED;;;AACAD,iBAAiB,CAACE,SAAlB,CAA4BC,cAA5B,GAA6C,YAAW;AACtD,MAAIC,WAAW,GAAG,IAAlB,CADsD,CAGtD;;AACA,OAAKC,aAAL,CAAmBC,QAAnB,GAA8BC,OAA9B,CAAsC,UAASC,IAAT,EAAc;AAClD,QAAIJ,WAAW,KAAK,IAApB,EAA0B;AACxB,UAAI,CAACI,IAAI,CAACC,+BAAV,EAA2C;AACzCL,QAAAA,WAAW,GAAGI,IAAd;AACD;AACF,KAJD,MAKK;AACH,UAAKA,IAAI,CAACE,KAAL,KAAeN,WAAW,CAACM,KAAZ,EAAhB,IACF,CAACF,IAAI,CAACC,+BADR,EACyC;AACvCL,QAAAA,WAAW,GAAGI,IAAd;AACD;AACF;AACF,GAZD;;AAcA,MAAIJ,WAAW,KAAK,IAApB,EAA0B;AACxBA,IAAAA,WAAW,CAACK,+BAAZ,GAA8C,IAA9C;AACD,GApBqD,CAqBtD;;;AACA,SAAOL,WAAP;AACD,CAvBD;;AAyBAJ,iBAAiB,CAACE,SAAlB,CAA4BS,aAA5B,GAA4C,UAASH,IAAT,EAAeI,CAAf,EAAkBC,CAAlB,EAAqB;AAC/D,MAAI,CAAC,KAAKC,cAAL,CAAoBN,IAAI,CAACO,GAAL,EAApB,CAAL,EAAsC;AACpC,SAAKD,cAAL,CAAoBN,IAAI,CAACO,GAAL,EAApB,IAAkC,EAAlC;AACD;;AACD,MAAI,CAAC,KAAKD,cAAL,CAAoBN,IAAI,CAACO,GAAL,EAApB,EAAgCH,CAAhC,CAAL,EAAyC;AACvC,SAAKE,cAAL,CAAoBN,IAAI,CAACO,GAAL,EAApB,EAAgCH,CAAhC,IAAqC,EAArC;AACD;;AACD,OAAKE,cAAL,CAAoBN,IAAI,CAACO,GAAL,EAApB,EAAgCH,CAAhC,EAAmCC,CAAnC,IAAwC,IAAxC;AACD,CARD;;AAUAb,iBAAiB,CAACE,SAAlB,CAA4Bc,aAA5B,GAA4C,UAASJ,CAAT,EAAYC,CAAZ,EAAeL,IAAf,EAAqB;AAC/D,MAAI,CAAC,KAAKS,cAAL,CAAoBL,CAApB,CAAL,EAA6B;AAC3B,SAAKK,cAAL,CAAoBL,CAApB,IAAyB,EAAzB;AACD;;AACD,MAAI,CAAC,KAAKK,cAAL,CAAoBL,CAApB,EAAuBC,CAAvB,CAAL,EAAgC;AAC9B,SAAKI,cAAL,CAAoBL,CAApB,EAAuBC,CAAvB,IAA4B,EAA5B;AACD;;AACD,OAAKI,cAAL,CAAoBL,CAApB,EAAuBC,CAAvB,EAA0BL,IAAI,CAACO,GAAL,EAA1B,IAAwCP,IAAxC;AACD,CARD;;AAUAR,iBAAiB,CAACE,SAAlB,CAA4BgB,qBAA5B,GAAoD,UAASN,CAAT,EAAYC,CAAZ,EAAeL,IAAf,EAAqB;AACvE,OAAKG,aAAL,CAAmBH,IAAnB,EAAyBI,CAAzB,EAA4BC,CAA5B;AACA,OAAKG,aAAL,CAAmBJ,CAAnB,EAAsBC,CAAtB,EAAyBL,IAAzB;AACD,CAHD;;AAKAR,iBAAiB,CAACE,SAAlB,CAA4BiB,wBAA5B,GAAuD,UAASP,CAAT,EAAYC,CAAZ,EAAeL,IAAf,EAAqB;AAC1E,MAAI,KAAKS,cAAL,CAAoBL,CAApB,CAAJ,EAA4B;AAC1B,QAAI,KAAKK,cAAL,CAAoBL,CAApB,EAAuBC,CAAvB,CAAJ,EAA+B;AAC7B,UAAI,KAAKI,cAAL,CAAoBL,CAApB,EAAuBC,CAAvB,EAA0BL,IAAI,CAACO,GAAL,EAA1B,CAAJ,EAA2C;AACzC,eAAO,IAAP;AACD;AACF;AACF;;AACD,SAAO,KAAP;AACD,CATD,C,CAWA;;;AACAf,iBAAiB,CAACE,SAAlB,CAA4BkB,QAA5B,GAAuC,UAASZ,IAAT,EAAe;AACpD,MAAIa,IAAI,GAAG,IAAX;AACA,MAAIC,MAAM,GAAG,EAAb;AACAC,EAAAA,MAAM,CAACC,IAAP,CAAY,KAAKV,cAAL,CAAoBN,IAAI,CAACO,GAAL,EAApB,CAAZ,EAA6CR,OAA7C,CAAqD,UAASK,CAAT,EAAY;AAC/DW,IAAAA,MAAM,CAACC,IAAP,CAAYH,IAAI,CAACP,cAAL,CAAoBN,IAAI,CAACO,GAAL,EAApB,EAAgCH,CAAhC,CAAZ,EAAgDL,OAAhD,CAAwD,UAASM,CAAT,EAAY;AAClE;AACAS,MAAAA,MAAM,CAACG,IAAP,CAAY,CAAC,CAACb,CAAF,EAAK,CAACC,CAAN,CAAZ;AACD,KAHD;AAID,GALD,EAHoD,CASpD;;AACA,SAAOS,MAAP;AACD,CAXD,C,CAaA;;;AACAtB,iBAAiB,CAACE,SAAlB,CAA4BI,QAA5B,GAAuC,UAASM,CAAT,EAAYC,CAAZ,EAAe;AACpD,MAAIS,MAAM,GAAG,EAAb;AACA,MAAID,IAAI,GAAG,IAAX;;AAEA,MAAI,KAAKJ,cAAL,CAAoBL,CAApB,CAAJ,EAA4B;AAC1B,QAAI,KAAKK,cAAL,CAAoBL,CAApB,EAAuBC,CAAvB,CAAJ,EAA+B;AAC7BS,MAAAA,MAAM,GAAGC,MAAM,CAACC,IAAP,CAAY,KAAKP,cAAL,CAAoBL,CAApB,EAAuBC,CAAvB,CAAZ,EAAuCa,GAAvC,CAA2C,UAASX,GAAT,EAAc;AAChE,eAAOM,IAAI,CAACJ,cAAL,CAAoBL,CAApB,EAAuBC,CAAvB,EAA0BE,GAA1B,CAAP;AACD,OAFQ,CAAT;AAGD;AACF;;AACD,SAAOO,MAAP;AACD,CAZD;;AAcAtB,iBAAiB,CAACE,SAAlB,CAA4ByB,sBAA5B,GAAqD,UAASf,CAAT,EAAYC,CAAZ,EAAeL,IAAf,EAAqB;AACxE;AACA,MAAI,KAAKM,cAAL,CAAoBN,IAAI,CAACO,GAAL,EAApB,CAAJ,EAAqC;AACnC,QAAI,KAAKD,cAAL,CAAoBN,IAAI,CAACO,GAAL,EAApB,EAAgCH,CAAhC,CAAJ,EAAwC;AACtC,UAAI,KAAKE,cAAL,CAAoBN,IAAI,CAACO,GAAL,EAApB,EAAgCH,CAAhC,EAAmCC,CAAnC,CAAJ,EAA2C;AACzC,eAAO,KAAKC,cAAL,CAAoBN,IAAI,CAACO,GAAL,EAApB,EAAgCH,CAAhC,EAAmCC,CAAnC,CAAP;AACD;AACF;AACF,GARuE,CAUxE;;;AACA,MAAI,KAAKI,cAAL,CAAoBL,CAApB,CAAJ,EAA4B;AAC1B,QAAI,KAAKK,cAAL,CAAoBL,CAApB,EAAuBC,CAAvB,CAAJ,EAA+B;AAC7B,UAAI,KAAKI,cAAL,CAAoBL,CAApB,EAAuBC,CAAvB,EAA0BL,IAAI,CAACO,GAAL,EAA1B,CAAJ,EAA2C;AACzC,eAAO,KAAKE,cAAL,CAAoBL,CAApB,EAAuBC,CAAvB,EAA0BL,IAAI,CAACO,GAAL,EAA1B,CAAP;AACD;AACF;AACF;AACF,CAlBD,C,CAoBA;;;AACAf,iBAAiB,CAACE,SAAlB,CAA4B0B,SAA5B,GAAwC,UAASpB,IAAT,EAAeI,CAAf,EAAkBC,CAAlB,EAAqB;AAC3D;AACA,MAAIgB,KAAK,GAAG,KAAKC,MAAL,CAAYC,SAAZ,CAAsBnB,CAAtB,EAAyBoB,WAAzB,CAAqCnB,CAArC,CAAZ;AACA,MAAIoB,QAAQ,GAAGJ,KAAK,CAACK,GAArB;AACA,MAAIC,MAAM,GAAGN,KAAK,CAACO,OAAnB;AACA,MAAIC,MAAM,GAAGR,KAAK,CAACQ,MAAnB;;AACA,MAAIJ,QAAQ,KAAKE,MAAjB,EAAyB;AACvB;AACA,QAAIE,MAAM,KAAKJ,QAAf,EAAyB;AACvB;AACAzB,MAAAA,IAAI,CAAC8B,QAAL,GAFuB,CAGvB;;AACA9B,MAAAA,IAAI,CAACC,+BAAL,GAAuC,KAAvC,CAJuB,CAKvB;AACD,KAND,MAOK;AACH;AACAD,MAAAA,IAAI,CAAC+B,OAAL,GAFG,CAGH;AACD;AACF,GAdD,MAeK;AACH;AACA,QAAIF,MAAM,KAAKJ,QAAf,EAAyB;AACvB;AACAzB,MAAAA,IAAI,CAAC+B,OAAL,GAFuB,CAGvB;AAGD,KAND,MAOK;AACH;AACA/B,MAAAA,IAAI,CAACgC,QAAL,GAFG,CAGH;;AACAhC,MAAAA,IAAI,CAACC,+BAAL,GAAuC,KAAvC,CAJG,CAKH;AACD;AACF,GArC0D,CAsC3D;;AACD,CAvCD,C,CAyCA;;;AACAT,iBAAiB,CAACE,SAAlB,CAA4BuC,qBAA5B,GAAoD,UAAS7B,CAAT,EAAYC,CAAZ,EAAe;AACjE,MAAI6B,QAAQ,GAAG,KAAKZ,MAAL,CAAYC,SAAZ,CAAsBnB,CAAtB,CAAf;AACA,MAAIiB,KAAK,GAAGa,QAAQ,CAACV,WAAT,CAAqBnB,CAArB,CAAZ,CAFiE,CAGjE;;AACA,MAAIsB,MAAM,GAAGN,KAAK,CAACO,OAAnB,CAJiE,CAKjE;AACA;;AACA,MAAIC,MAAM,GAAGR,KAAK,CAACK,GAAnB,CAPiE,CAQjE;;AAEA,MAAIS,QAAQ,GAAG,IAAI9C,OAAJ,EAAf,CAViE,CAWjE;;AACA,MAAIsC,MAAM,KAAKE,MAAf,EAAuB;AACrB,WAAOM,QAAP;AACD;;AAED,OAAKC,SAAL,CAAerC,OAAf,CAAuB,UAASsC,QAAT,EAAmB;AACxC,QAAIA,QAAQ,CAACC,cAAT,CAAwBJ,QAAxB,EAAkC7B,CAAlC,CAAJ,EAA0C;AACxC,UAAIgC,QAAQ,CAACE,IAAT,CAAcC,YAAd,KAA+B,CAAnC,EAAsC;AACpCH,QAAAA,QAAQ,CAACE,IAAT,CAAcE,gBAAd,CAA+BP,QAA/B,EAAyC7B,CAAzC,EAA4CN,OAA5C,CAAoD,UAAU2C,KAAV,EAAiB;AACnEP,UAAAA,QAAQ,CAACQ,OAAT,CAAiB,IAAIxD,kBAAJ,CAAuBwC,MAAvB,EAA+BE,MAA/B,EAAuCQ,QAAQ,CAACO,aAAhD,EAA+DF,KAA/D,CAAjB;AACD,SAFD;AAGD,OAJD,MAKK;AACH,YAAIL,QAAQ,CAACE,IAAT,CAAcC,YAAd,KAA+B,CAAnC,EAAsC;AACpCH,UAAAA,QAAQ,CAACE,IAAT,CAAcE,gBAAd,CAA+BP,QAA/B,EAAyC7B,CAAzC,EAA4CN,OAA5C,CAAoD,UAAU8C,MAAV,EAAkB;AACpER,YAAAA,QAAQ,CAACE,IAAT,CAAcO,gBAAd,CAA+BZ,QAA/B,EAAyC7B,CAAzC,EAA4CN,OAA5C,CAAoD,UAAUgD,MAAV,EAAkB;AACpEZ,cAAAA,QAAQ,CAACQ,OAAT,CAAiB,IAAIxD,kBAAJ,CAAuBwC,MAAvB,EAA+BE,MAA/B,EAAuCQ,QAAQ,CAACO,aAAhD,EAA+DC,MAA/D,EAAuEE,MAAvE,CAAjB;AACD,aAFD;AAGD,WAJD;AAKD,SAND,MAOK;AACH;AACAZ,UAAAA,QAAQ,CAACQ,OAAT,CAAiB,IAAIxD,kBAAJ,CAAuBwC,MAAvB,EAA+BE,MAA/B,EAAuCQ,QAAQ,CAACO,aAAhD,CAAjB;AACD;AACF;AACF;AACF,GArBD;AAsBA,SAAOT,QAAP;AACD,CAvCD,C,CAyCA;;;AACA3C,iBAAiB,CAACE,SAAlB,CAA4BsD,oBAA5B,GAAmD,YAAW;AAC5D;AACA,MAAInC,IAAI,GAAG,IAAX;AACA,OAAKS,MAAL,CAAYC,SAAZ,CAAsBxB,OAAtB,CAA8B,UAASmC,QAAT,EAAmB9B,CAAnB,EAAsB;AAClD8B,IAAAA,QAAQ,CAACV,WAAT,CAAqBzB,OAArB,CAA6B,UAASsB,KAAT,EAAgBhB,CAAhB,EAAmB;AAC9C;AACA,UAAI8B,QAAQ,GAAGtB,IAAI,CAACoB,qBAAL,CAA2B7B,CAA3B,EAA8BC,CAA9B,CAAf;AACA8B,MAAAA,QAAQ,CAACrC,QAAT,GAAoBC,OAApB,CAA4B,UAASC,IAAT,EAAe;AACzCa,QAAAA,IAAI,CAAChB,aAAL,CAAmB8C,OAAnB,CAA2B3C,IAA3B,EADyC,CAEzC;AACD,OAHD;AAID,KAPD;AAQD,GATD,EAH4D,CAa5D;AACD,CAdD,C,CAgBA;AACA;;;AACAR,iBAAiB,CAACE,SAAlB,CAA4BuD,YAA5B,GAA2C,YAAW;AACpD;AACA,MAAIpC,IAAI,GAAG,IAAX,CAFoD,CAIpD;;AACA,OAAKS,MAAL,CAAYC,SAAZ,CAAsBxB,OAAtB,CAA8B,UAASmC,QAAT,EAAmB9B,CAAnB,EAAsB;AAClD,QAAIA,CAAC,GAAG,GAAJ,KAAY,CAAhB,EAAmB,CACjB;AACD;;AAED,QAAI8C,cAAc,GAAG,IAAI5D,QAAJ,EAArB;AACA4C,IAAAA,QAAQ,CAACV,WAAT,CAAqBzB,OAArB,CAA6B,UAASoD,UAAT,EAAqB;AAChDD,MAAAA,cAAc,CAACE,aAAf,CAA6BD,UAAU,CAAC9B,KAAxC,EAA+C8B,UAAU,CAACvB,OAA1D;AACD,KAFD;AAIAM,IAAAA,QAAQ,CAACV,WAAT,CAAqBzB,OAArB,CAA6B,UAASsB,KAAT,EAAgBhB,CAAhB,EAAmB;AAC9CQ,MAAAA,IAAI,CAAChB,aAAL,CAAmBC,QAAnB,GAA8BC,OAA9B,CAAsC,UAASC,IAAT,EAAe;AACnD,YAAIA,IAAI,CAACqD,cAAL,CAAoBnB,QAApB,EAA8BgB,cAA9B,EAA8C7C,CAA9C,CAAJ,EAAsD;AACpDQ,UAAAA,IAAI,CAACH,qBAAL,CAA2BN,CAA3B,EAA8BC,CAA9B,EAAiCL,IAAjC;AACAa,UAAAA,IAAI,CAACO,SAAL,CAAepB,IAAf,EAAqBI,CAArB,EAAwBC,CAAxB,EAFoD,CAGpD;AACD;AACF,OAND;AAOD,KARD;AASD,GAnBD,EALoD,CA0BpD;AACD,CA3BD,C,CA6BA;;;AACAb,iBAAiB,CAACE,SAAlB,CAA4B4D,aAA5B,GAA4C,UAASlD,CAAT,EAAYC,CAAZ,EAAe;AACzD,MAAIkD,cAAc,GAAG,KAAKjC,MAAL,CAAYC,SAAZ,CAAsBnB,CAAtB,EAAyBoD,MAA9C;AACA,MAAIC,IAAI,GAAG,EAAX;;AAEA,MAAI,KAAKC,KAAL,GAAa,CAAjB,EAAoB;AAClBD,IAAAA,IAAI,CAACxC,IAAL,CAAU,CAACb,CAAD,EAAIC,CAAC,GAAG,CAAR,CAAV;AACD;;AACD,MAAI,KAAKqD,KAAL,GAAa,CAAjB,EAAoB;AAClBD,IAAAA,IAAI,CAACxC,IAAL,CAAU,CAACb,CAAD,EAAIC,CAAC,GAAG,CAAR,CAAV;AACD;;AACD,MAAI,KAAKqD,KAAL,GAAa,CAAjB,EAAoB;AAClBD,IAAAA,IAAI,CAACxC,IAAL,CAAU,CAACb,CAAD,EAAIC,CAAC,GAAG,CAAR,CAAV;AACD;;AACD,MAAI,KAAKqD,KAAL,GAAaH,cAAc,GAAG,CAAlC,EAAqC;AACnCE,IAAAA,IAAI,CAACxC,IAAL,CAAU,CAACb,CAAD,EAAIC,CAAC,GAAG,CAAR,CAAV;AACD;;AACD,MAAI,KAAKqD,KAAL,GAAaH,cAAc,GAAG,CAAlC,EAAqC;AACnCE,IAAAA,IAAI,CAACxC,IAAL,CAAU,CAACb,CAAD,EAAIC,CAAC,GAAG,CAAR,CAAV;AACD;;AACD,MAAI,KAAKqD,KAAL,GAAaH,cAAc,GAAG,CAAlC,EAAqC;AACnCE,IAAAA,IAAI,CAACxC,IAAL,CAAU,CAACb,CAAD,EAAIC,CAAC,GAAG,CAAR,CAAV;AACD;;AACD,SAAOoD,IAAP;AACD,CAvBD,C,CAyBA;AACA;AACA;;;AACAjE,iBAAiB,CAACE,SAAlB,CAA4BiE,KAA5B,GAAoC,UAASrC,MAAT,EAAiBc,SAAjB,EAA4BwB,OAA5B,EAAqC;AACvE,OAAKtC,MAAL,GAAcA,MAAd;AACA,OAAKc,SAAL,GAAiBA,SAAjB;AACA,OAAKvC,aAAL,GAAqB,IAAIR,OAAJ,EAArB;AACA,OAAKiB,cAAL,GAAsB,EAAtB;AACA,OAAKG,cAAL,GAAsB,EAAtB,CALuE,CAOvE;;AACA,OAAKa,MAAL,CAAYI,GAAZ,CAAgBkC,OAAhB;AACA,OAAKZ,oBAAL,GATuE,CAUvE;;AACA,OAAKC,YAAL;AAEA,MAAIY,QAAQ,GAAG,KAAKlE,cAAL,EAAf;AACA,MAAImE,eAAe,GAAG,CAAtB;AACA,MAAIjD,IAAI,GAAG,IAAX;;AACA,SAAQgD,QAAQ,KAAK,IAAd,IAAwBA,QAAQ,CAAC3D,KAAT,KAAmBX,QAAlD,EAA6D;AAC3D,QAAKuE,eAAe,GAAG,CAAnB,KAA0B,CAA9B,EAAiC,CAEhC,CAFD,CACE;AAEF;AACA;AACA;AAEA;;;AACA,SAAKlD,QAAL,CAAciD,QAAd,EAAwB9D,OAAxB,CAAgC,UAASgE,IAAT,EAAe;AAC7C;AACA;AACAF,MAAAA,QAAQ,CAACG,OAAT,CAAiBnD,IAAI,CAACS,MAAL,CAAYC,SAAZ,CAAsBwC,IAAI,CAAC,CAAD,CAA1B,CAAjB,EAAiDA,IAAI,CAAC,CAAD,CAArD;AACD,KAJD;AAMA,QAAIE,WAAW,GAAG,IAAI5E,OAAJ,EAAlB;AACA,SAAKuB,QAAL,CAAciD,QAAd,EAAwB9D,OAAxB,CAAgC,UAASgE,IAAT,EAAe;AAC7ClD,MAAAA,IAAI,CAACyC,aAAL,CAAmBS,IAAI,CAAC,CAAD,CAAvB,EAA4BA,IAAI,CAAC,CAAD,CAAhC,EAAqChE,OAArC,CAA6C,UAASmE,QAAT,EAAmB;AAC9D;AACA,YAAI/B,QAAQ,GAAGtB,IAAI,CAACoB,qBAAL,CAA2BiC,QAAQ,CAAC,CAAD,CAAnC,EAAwCA,QAAQ,CAAC,CAAD,CAAhD,CAAf,CAF8D,CAI9D;AACA;;AACArD,QAAAA,IAAI,CAACf,QAAL,CAAcoE,QAAQ,CAAC,CAAD,CAAtB,EAA2BA,QAAQ,CAAC,CAAD,CAAnC,EAAwCnE,OAAxC,CAAgD,UAASC,IAAT,EAAe;AAC7D,cAAI,CAACmC,QAAQ,CAACgC,OAAT,CAAiBnE,IAAjB,CAAL,EAA6B;AAC3Ba,YAAAA,IAAI,CAACM,sBAAL,CAA4B+C,QAAQ,CAAC,CAAD,CAApC,EAAyCA,QAAQ,CAAC,CAAD,CAAjD,EAAsDlE,IAAtD;AACD;AACF,SAJD,EAN8D,CAY9D;;AACAmC,QAAAA,QAAQ,CAACrC,QAAT,GAAoBC,OAApB,CAA4B,UAASC,IAAT,EAAe;AACzC,cAAI,CAACa,IAAI,CAACF,wBAAL,CAA8BuD,QAAQ,CAAC,CAAD,CAAR,CAAaA,QAAb,CAAsB,CAAtB,CAA9B,EAAwDlE,IAAxD,CAAL,EAAoE;AAClE,gBAAIa,IAAI,CAAChB,aAAL,CAAmBsE,OAAnB,CAA2BnE,IAA3B,CAAJ,EAAsC;AACpCa,cAAAA,IAAI,CAACH,qBAAL,CAA2BwD,QAAQ,CAAC,CAAD,CAAnC,EAAwCA,QAAQ,CAAC,CAAD,CAAhD,EAAqDlE,IAArD;AACD,aAFD,MAGK;AACHiE,cAAAA,WAAW,CAACtB,OAAZ,CAAoB3C,IAApB;AACD;AACF;AACF,SATD,EAb8D,CAwB9D;;AACA,YAAIiE,WAAW,CAACG,OAAZ,KAAwB,CAA5B,EAA+B;AAC7BH,UAAAA,WAAW,CAACnE,QAAZ,GAAuBC,OAAvB,CAA+B,UAASC,IAAT,EAAe;AAC5Ca,YAAAA,IAAI,CAAChB,aAAL,CAAmB8C,OAAnB,CAA2B3C,IAA3B;AACD,WAFD;AAGAa,UAAAA,IAAI,CAACS,MAAL,CAAYC,SAAZ,CAAsBxB,OAAtB,CAA8B,UAAUmC,QAAV,EAAoB9B,CAApB,EAAuB;AACnD,gBAAI8C,cAAc,GAAGhB,QAAQ,CAAChB,GAAT,CAAa,UAASG,KAAT,EAAgB;AAChD,qBAAO,CAACA,KAAK,CAACA,KAAP,EAAcA,KAAK,CAACO,OAApB,CAAP;AACD,aAFoB,CAArB;AAGAM,YAAAA,QAAQ,CAACnC,OAAT,CAAiB,UAASsB,KAAT,EAAgBhB,CAAhB,EAAmB;AAClC4D,cAAAA,WAAW,CAACnE,QAAZ,GAAuBC,OAAvB,CAA+B,UAASC,IAAT,EAAe;AAC5C,oBAAIA,IAAI,CAACqD,cAAL,CAAoBnB,QAApB,EAA8BgB,cAA9B,EAA8C7C,CAA9C,CAAJ,EAAsD;AACpDQ,kBAAAA,IAAI,CAACH,qBAAL,CAA2BN,CAA3B,EAA8BC,CAA9B,EAAiCL,IAAjC;AACAa,kBAAAA,IAAI,CAACO,SAAL,CAAepB,IAAf,EAAqBI,CAArB,EAAwBC,CAAxB;AACD;AACF,eALD;AAMD,aAPD;AAQD,WAZD;AAaD;AAEF,OA5CD;AA6CD,KA9CD,EAhB2D,CAgE3D;;AACAwD,IAAAA,QAAQ,GAAG,KAAKlE,cAAL,EAAX;AACAmE,IAAAA,eAAe;AAChB,GAnFsE,CAoFvE;AACA;AAEA;;;AACA,OAAKjE,aAAL,CAAmBC,QAAnB,GAA8BC,OAA9B,CAAsC,UAASC,IAAT,EAAe;AACnD,QAAIA,IAAI,CAACE,KAAL,KAAeW,IAAI,CAACpB,kBAAxB,EAA4C;AAC1CoB,MAAAA,IAAI,CAAChB,aAAL,CAAmBwE,UAAnB,CAA8BrE,IAA9B;AACD;AACF,GAJD,EAxFuE,CA8FvE;AACA;;AACA,SAAO,KAAKH,aAAZ;AACD,CAjGD;;AAmGAL,iBAAiB,CAACE,SAAlB,CAA4B4E,oBAA5B,GAAmD,YAAW;AAC5D,MAAIzD,IAAI,GAAG,IAAX;AACA,MAAIC,MAAM,GAAG,EAAb;;AAEA,WAASyD,YAAT,CAAsBC,CAAtB,EAAyBC,CAAzB,EAA4B;AAC1B,QAAID,CAAC,CAACtE,KAAF,KAAYuE,CAAC,CAACvE,KAAF,EAAhB,EAA2B;AACzB,aAAO,CAAC,CAAR;AACD,KAFD,MAGK;AACH,UAAIsE,CAAC,CAACtE,KAAF,KAAYuE,CAAC,CAACvE,KAAF,EAAhB,EAA2B;AACzB,eAAO,CAAP;AACD,OAFD,MAGK;AACH,eAAO,CAAP;AACD;AACF;AACF;;AAED,MAAIwE,KAAK,GAAG,KAAK7E,aAAL,CAAmBC,QAAnB,EAAZ;AACA,MAAI6E,WAAW,GAAGD,KAAK,CAACE,IAAN,CAAWL,YAAX,CAAlB;AAEAI,EAAAA,WAAW,CAAC5E,OAAZ,CAAoB,UAASC,IAAT,EAAe;AACjC;AACEc,IAAAA,MAAM,IAAId,IAAI,CAACE,KAAL,KAAe,IAAf,GAAsBF,IAAI,CAAC8B,QAA3B,GAAsC,IAAtC,GAA6C9B,IAAI,CAACgC,QAAlD,GAA6D,IAA7D,GAAoEhC,IAAI,CAAC+B,OAAzE,GAAmF,IAAnF,GAA0F/B,IAAI,CAAC6E,WAAL,EAA1F,GAA+G,IAAzH,CAF+B,CAGjC;AACD,GAJD;AAKA,SAAO/D,MAAP;AACD,CA3BD;;AA6BAgE,MAAM,CAACC,OAAP,GAAiBvF,iBAAjB","sourcesContent":["/*\n  Brill POS Trainer class\n  Copyright (C) 2017 Hugo W.L. ter Doest\n\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n// Algorithm is based on:\n// Exploring the Statistical Derivation of Transformational Rule Sequences\n// for Part-of-Speech Tagging, Lance A. Ramshaw and Mitchell P. Marcus\n// http://acl-arc.comp.nus.edu.sg/archives/acl-arc-090501d4/data/pdf/anthology-PDF/W/W94/W94-0111.pdf\n\n//var log4js = require('log4js');\n//var logger = log4js.getLogger('Brill_POS_Trainer');\n//logger.setLevel('OFF');\n\nvar TransformationRule = require(\"./TransformationRule\");\nvar RuleSet = require(\"./RuleSet\");\nvar Sentence = require('./Sentence');\n\n// Training continues as long as there are rules with a positive score\n// that have not been selected before\nvar minScore = 0;\n\n// After training rules with a score below scoreThreshold are pruned\nfunction Brill_POS_Trainer(ruleScoreThreshold) {\n  if (ruleScoreThreshold) {\n    this.ruleScoreThreshold = ruleScoreThreshold;\n  }\n  else {\n    this.ruleScoreThreshold = 1;\n  }\n}\n\n// Return the highest scoring rule from the rule set\nBrill_POS_Trainer.prototype.selectHighRule = function() {\n  var highestRule = null;\n\n  // Walk through the map and find the rule with highest score\n  this.positiveRules.getRules().forEach(function(rule){\n    if (highestRule === null) {\n      if (!rule.hasBeenSelectedAsHighRuleBefore) {\n        highestRule = rule;\n      }\n    }\n    else {\n      if ((rule.score() > highestRule.score()) &&\n        !rule.hasBeenSelectedAsHighRuleBefore) {\n        highestRule = rule;\n      }\n    }\n  });\n\n  if (highestRule !== null) {\n    highestRule.hasBeenSelectedAsHighRuleBefore = true;\n  }\n  // Return the rule with the highest score\n  return highestRule;\n};\n\nBrill_POS_Trainer.prototype.mapRuleToSite = function(rule, i, j) {\n  if (!this.mapRuleToSites[rule.key()]) {\n    this.mapRuleToSites[rule.key()] = {};\n  }\n  if (!this.mapRuleToSites[rule.key()][i]) {\n    this.mapRuleToSites[rule.key()][i] = {};\n  }\n  this.mapRuleToSites[rule.key()][i][j] = true;\n};\n\nBrill_POS_Trainer.prototype.mapSiteToRule = function(i, j, rule) {\n  if (!this.mapSiteToRules[i]) {\n    this.mapSiteToRules[i] = {};\n  }\n  if (!this.mapSiteToRules[i][j]) {\n    this.mapSiteToRules[i][j] = {};\n  }\n  this.mapSiteToRules[i][j][rule.key()] = rule;\n};\n\nBrill_POS_Trainer.prototype.associateSiteWithRule = function(i, j, rule) {\n  this.mapRuleToSite(rule, i, j);\n  this.mapSiteToRule(i, j, rule);\n};\n\nBrill_POS_Trainer.prototype.siteIsAssociatedWithRule = function(i, j, rule) {\n  if (this.mapSiteToRules[i]) {\n    if (this.mapSiteToRules[i][j]) {\n      if (this.mapSiteToRules[i][j][rule.key()]) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n// Returns an array of all sites associated with rule\nBrill_POS_Trainer.prototype.getSites = function(rule) {\n  var that = this;\n  var result = [];\n  Object.keys(this.mapRuleToSites[rule.key()]).forEach(function(i) {\n    Object.keys(that.mapRuleToSites[rule.key()][i]).forEach(function(j) {\n      // Unary plus the convert hash keys i and j to integer\n      result.push([+i, +j]);\n    });\n  });\n  //logger.debug(\"Brill_POS_Trainer.prototype.getSites: sites \" + JSON.stringify(result));\n  return(result);\n};\n\n// Returns an array of all rules associated with the site\nBrill_POS_Trainer.prototype.getRules = function(i, j) {\n  var result = [];\n  var that = this;\n\n  if (this.mapSiteToRules[i]) {\n    if (this.mapSiteToRules[i][j]) {\n      result = Object.keys(this.mapSiteToRules[i][j]).map(function(key) {\n        return that.mapSiteToRules[i][j][key];\n      });\n    }\n  }\n  return result;\n};\n\nBrill_POS_Trainer.prototype.disconnectSiteFromRule = function(i, j, rule) {\n  // mapRuleToSites\n  if (this.mapRuleToSites[rule.key()]) {\n    if (this.mapRuleToSites[rule.key()][i]) {\n      if (this.mapRuleToSites[rule.key()][i][j]) {\n        delete this.mapRuleToSites[rule.key()][i][j];\n      }\n    }\n  }\n\n  // mapSiteToRules\n  if (this.mapSiteToRules[i]) {\n    if (this.mapSiteToRules[i][j]) {\n      if (this.mapSiteToRules[i][j][rule.key()]) {\n        delete this.mapSiteToRules[i][j][rule.key()];\n      }\n    }\n  }\n};\n\n// Adjusts the score of the rule at position i, j of the corpus\nBrill_POS_Trainer.prototype.scoreRule = function(rule, i, j) {\n  //logger.debug(\"Brill_POS_Trainer.prototype.scoreRule: entry\");\n  var token = this.corpus.sentences[i].taggedWords[j];\n  var rightTag = token.tag;\n  var oldTag = token.testTag;\n  var newTag = token.newTag;\n  if (rightTag !== oldTag) {\n    // Old tag is wrong\n    if (newTag === rightTag) {\n      // New tag is right\n      rule.positive++;\n      // If the score changes, it may be selected again as highest scoring rule\n      rule.hasBeenSelectedAsHighRuleBefore = false;\n      //logger.debug(\"Brill_POS_Trainer.prototype.scoreRule: positive: \" + rule.key() + \"\\t score: \" + rule.positive);\n    }\n    else {\n      // New tag is wrong as well --> neutral\n      rule.neutral++;\n      //logger.debug(\"Brill_POS_Trainer.prototype.scoreRule: neutral: \" + rule.key() + \"\\t score: \" + rule.neutral);\n    }\n  }\n  else {\n    // Old tag is right\n    if (newTag === rightTag) {\n      // New tag is right --> neutral\n      rule.neutral++;\n      //logger.debug(\"Brill_POS_Trainer.prototype.scoreRule: neutral: \" + rule.key() + \"\\t score: \" + rule.neutral);\n\n\n    }\n    else {\n      // New tag is false\n      rule.negative++;\n      // If the score changes, it may be selected again as highest scoring rule\n      rule.hasBeenSelectedAsHighRuleBefore = false;\n      //logger.debug(\"Brill_POS_Trainer.prototype.scoreRule: negative: \" + rule.key() + \"\\t score: \" + rule.negative);\n    }\n  }\n  //logger.debug(\"Brill_POS_Trainer.prototype.scoreRule: exit\");\n};\n\n// Generate positive rules for this given site using templates\nBrill_POS_Trainer.prototype.generatePositiveRules = function(i, j) {\n  var sentence = this.corpus.sentences[i];\n  var token = sentence.taggedWords[j];\n  // A positive rule should trigger on the currently assigned testTag\n  var oldTag = token.testTag;\n  //logger.debug(\"Brill_POS_Trainer.prototype.generatePositiveRules: oldTag \" + oldTag);\n  // It should assign the right tag as given by the corpus\n  var newTag = token.tag;\n  //logger.debug(\"Brill_POS_Trainer.prototype.generatePositiveRules: newTag \" + newTag);\n\n  var newRules = new RuleSet();\n  // Exit if testTag already is the right tag --> will not result in positive rules\n  if (oldTag === newTag) {\n    return newRules;\n  }\n\n  this.templates.forEach(function(template) {\n    if (template.windowFitsSite(sentence, j)) {\n      if (template.meta.nrParameters === 1) {\n        template.meta.parameter1Values(sentence, j).forEach(function (value) {\n          newRules.addRule(new TransformationRule(oldTag, newTag, template.predicateName, value));\n        });\n      }\n      else {\n        if (template.meta.nrParameters === 2) {\n          template.meta.parameter1Values(sentence, j).forEach(function (value1) {\n            template.meta.parameter2Values(sentence, j).forEach(function (value2) {\n              newRules.addRule(new TransformationRule(oldTag, newTag, template.predicateName, value1, value2));\n            });\n          });\n        }\n        else {\n          // 0 paramaters\n          newRules.addRule(new TransformationRule(oldTag, newTag, template.predicateName));\n        }\n      }\n    }\n  });\n  return newRules;\n};\n\n// Finds all rules that are applicable at some site\nBrill_POS_Trainer.prototype.scanForPositiveRules = function() {\n  //logger.debug(\"Brill_POS_Trainer.prototype.scanForPositiveRules: entry\");\n  var that = this;\n  this.corpus.sentences.forEach(function(sentence, i) {\n    sentence.taggedWords.forEach(function(token, j) {\n      //logger.debug(\"Brill_POS_Trainer.prototype.scanForPositiveRules: sentence no \" + i);\n      var newRules = that.generatePositiveRules(i, j);\n      newRules.getRules().forEach(function(rule) {\n        that.positiveRules.addRule(rule);\n        //logger.debug(\"Brill_POS_Trainer.prototype.scanForPositiveRules: nrRules \" + that.positiveRules.nrRules());\n      });\n    });\n  });\n  //logger.debug(\"Brill_POS_Trainer.prototype.scanForPositiveRules: exit, number of rules: \" + this.positiveRules.nrRules());\n};\n\n// Find all sites where the rules can be applied, register these sites and\n// update the scores\nBrill_POS_Trainer.prototype.scanForSites = function() {\n  //logger.debug(\"Brill_POS_Trainer.prototype.scanForSites: entry\");\n  var that = this;\n\n  // Scan the corpus\n  this.corpus.sentences.forEach(function(sentence, i) {\n    if (i % 100 === 0) {\n      //logger.info(\"Brill_POS_Trainer.prototype.scanForSites: sentence \" + i);\n    }\n\n    var taggedSentence = new Sentence();\n    sentence.taggedWords.forEach(function(wordObject) {\n      taggedSentence.addTaggedWord(wordObject.token, wordObject.testTag);\n    });\n\n    sentence.taggedWords.forEach(function(token, j) {\n      that.positiveRules.getRules().forEach(function(rule) {\n        if (rule.isApplicableAt(sentence, taggedSentence, j)) {\n          that.associateSiteWithRule(i, j, rule);\n          that.scoreRule(rule, i, j);\n          //logger.debug(\"Brill_POS_Trainer.prototype.scanForSites: (sentence, token, rule): (\" + i + \", \" + j + \", \" + rule.prettyPrint() + \")\");\n        }\n      });\n    });\n  });\n\n  //logger.debug(\"Brill_POS_Trainer.prototype.scanForSites: exit\");\n};\n\n// Returns a list of sites that may have been touched by a changing tag\nBrill_POS_Trainer.prototype.neighbourhood = function(i, j) {\n  var sentenceLength = this.corpus.sentences[i].length;\n  var list = [];\n\n  if (this.index > 2) {\n    list.push([i, j - 3]);\n  }\n  if (this.index > 1) {\n    list.push([i, j - 2]);\n  }\n  if (this.index > 0) {\n    list.push([i, j - 1]);\n  }\n  if (this.index < sentenceLength - 1) {\n    list.push([i, j + 1]);\n  }\n  if (this.index < sentenceLength - 2) {\n    list.push([i, j + 2]);\n  }\n  if (this.index > sentenceLength - 3) {\n    list.push([i, j + 3]);\n  }\n  return list;\n};\n\n// corpus: an array of token arrays\n// templates: an array of rule templates\n// lexicon: lexicon that provides method tagWord(word)\nBrill_POS_Trainer.prototype.train = function(corpus, templates, lexicon) {\n  this.corpus = corpus;\n  this.templates = templates;\n  this.positiveRules = new RuleSet();\n  this.mapRuleToSites = {};\n  this.mapSiteToRules = {};\n\n  //logger.debug(\"Brill_POS_Trainer.prototype.train: entry\");\n  this.corpus.tag(lexicon);\n  this.scanForPositiveRules();\n  //logger.info(\"Brill_POS_Trainer.prototype.train: initial number of rules: \" + this.positiveRules.nrRules());\n  this.scanForSites();\n\n  var highRule = this.selectHighRule();\n  var iterationNumber = 0;\n  var that = this;\n  while ((highRule !== null) && (highRule.score() > minScore)) {\n    if ((iterationNumber % 5) === 0) {\n      //logger.info(\"Brill_POS_Trainer.prototype.train: training iteration: \" + iterationNumber);\n    }\n    //logger.debug(\"Brill_POS_Trainer.prototype.train: highRule selected: \" + highRule.key());\n    //logger.debug(\"Brill_POS_Trainer.prototype.train: number of rules: \" + this.positiveRules.nrRules());\n    //logger.debug(\"Brill_POS_Trainer.prototype.train: score of highRule: \" + highRule.score());\n\n    // Apply the high rule to each change site on its site list\n    this.getSites(highRule).forEach(function(site) {\n      //logger.debug(\"Brill_POS_Trainer.prototype.train: apply highRule to: \" + site);\n      //logger.debug(\"Brill_POS_Trainer.prototype.train: sentence length: \" + that.corpus.sentences[site[0]].length);\n      highRule.applyAt(that.corpus.sentences[site[0]], site[1]);\n    });\n\n    var unseenRules = new RuleSet();\n    this.getSites(highRule).forEach(function(site) {\n      that.neighbourhood(site[0], site[1]).forEach(function(testSite) {\n        // Generate positive rules for testSite\n        var newRules = that.generatePositiveRules(testSite[0], testSite[1]);\n\n        // Disconnect test site from its rules\n        // because highrule has been applied\n        that.getRules(testSite[0], testSite[1]).forEach(function(rule) {\n          if (!newRules.hasRule(rule)) {\n            that.disconnectSiteFromRule(testSite[0], testSite[1], rule);\n          }\n        });\n\n        // Connect new rules not already connected to the test site\n        newRules.getRules().forEach(function(rule) {\n          if (!that.siteIsAssociatedWithRule(testSite[0]. testSite[1], rule)) {\n            if (that.positiveRules.hasRule(rule)) {\n              that.associateSiteWithRule(testSite[0], testSite[1], rule);\n            }\n            else {\n              unseenRules.addRule(rule);\n            }\n          }\n        });\n\n        // Process unseen rules\n        if (unseenRules.nrRules() > 0) {\n          unseenRules.getRules().forEach(function(rule) {\n            that.positiveRules.addRule(rule);\n          });\n          that.corpus.sentences.forEach(function (sentence, i) {\n            var taggedSentence = sentence.map(function(token) {\n              return [token.token, token.testTag];\n            });\n            sentence.forEach(function(token, j) {\n              unseenRules.getRules().forEach(function(rule) {\n                if (rule.isApplicableAt(sentence, taggedSentence, j)) {\n                  that.associateSiteWithRule(i, j, rule);\n                  that.scoreRule(rule, i, j);\n                }\n              });\n            });\n          });\n        }\n\n      });\n    });\n\n    // Select next highest scoring rule\n    highRule = this.selectHighRule();\n    iterationNumber++;\n  }\n  //logger.info(\"Brill_POS_Trainer.prototype.train: number of iterations: \" + iterationNumber);\n  //logger.info(\"Brill_POS_Trainer.prototype.train: number of rules: \" + this.positiveRules.nrRules());\n\n  // Remove rules having a non-positive score\n  this.positiveRules.getRules().forEach(function(rule) {\n    if (rule.score() < that.ruleScoreThreshold) {\n      that.positiveRules.removeRule(rule);\n    }\n  });\n\n  //logger.info(\"Brill_POS_Trainer.prototype.train: number of rules after pruning: \" + this.positiveRules.nrRules());\n  //logger.debug(\"Brill_POS_Trainer.prototype.train: exit\");\n  return this.positiveRules;\n};\n\nBrill_POS_Trainer.prototype.printRulesWithScores = function() {\n  var that = this;\n  var result = \"\";\n\n  function compareRules(a, b) {\n    if (a.score() > b.score()) {\n      return -1;\n    }\n    else {\n      if (a.score() < b.score()) {\n        return 1;\n      }\n      else {\n        return 0;\n      }\n    }\n  }\n\n  var rules = this.positiveRules.getRules();\n  var sortedRules = rules.sort(compareRules);\n\n  sortedRules.forEach(function(rule) {\n    //if (rule.score() > 0) {\n      result += rule.score() + '\\t' + rule.positive + '\\t' + rule.negative + '\\t' + rule.neutral + '\\t' + rule.prettyPrint() + \"\\n\";\n    //}\n  });\n  return result;\n};\n\nmodule.exports = Brill_POS_Trainer;\n"]},"metadata":{},"sourceType":"script"}